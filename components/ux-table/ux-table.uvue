<template>
	<view class="ux-table">
		<view class="header">
			<view class="header-row">
				<view v-for="(col, index) in columns" :key="index" class="header-cell"
					:style="{ flex: getColFlex(index), width: getColWidth(index) }">
					<text class="header-text">{{ col['label'] }}</text>
					
					<!-- #ifdef H5 -->
					<view class="resize-handle" 
						@touchstart.stop.prevent="onResizeStart(index, $event)" 
						@touchmove.stop.prevent="onResizeMove" 
						@touchend="onResizeEnd"
						@mousedown.stop.prevent="onResizeStartMouse(index, $event)">
						<view class="separator-line"></view>
					</view>
					<!-- #endif -->
					<!-- #ifndef H5 -->
					<view class="resize-handle" 
						@touchstart.stop.prevent="onResizeStart(index, $event)" 
						@touchmove.stop.prevent="onResizeMove" 
						@touchend="onResizeEnd">
						<view class="separator-line"></view>
					</view>
					<!-- #endif -->
				</view>
			</view>
			
			<!-- Header Action: Expand/Collapse All (Floating on right) -->
			<view class="header-action" @click="toggleAll" hover-class="header-action-hover">
				<text class="action-text">{{ isAllExpanded ? '收起' : '展开' }}</text>
			</view>
		</view>
		<view class="body">
			<view v-for="(row, rowIndex) in visibleRows" :key="rowIndex" class="row" :class="{ 'row-selected': row.id === selectedRowId }" @click="handleRowClick(row)">
				<view v-for="(col, colIndex) in columns" :key="colIndex" class="cell"
					:style="{ flex: getColFlex(colIndex), width: getColWidth(colIndex) }">
					
					<view v-if="colIndex === 0" class="cell-content-wrapper">
						<view :style="{ width: (row.level * 40) + 'rpx' }"></view>
						<view class="expand-icon" @click.stop="toggleExpand(row)">
							<text class="icon-text" v-if="row.hasChildren">{{ row.expanded ? '▼' : '▶' }}</text>
							<text class="icon-text" v-else></text>
						</view>
						<text class="cell-text">{{ getStringValue(row.originData, col['prop'] as string) }}</text>
					</view>
					
					<view v-else class="cell-content-wrapper">
						<text class="cell-text">{{ getStringValue(row.originData, col['prop'] as string) }}</text>
					</view>
				</view>
			</view>
		</view>
	</view>
</template>

<script lang="uts">
	import { PropType } from 'vue'

	type TableRow = {
		id : string
		level : number
		expanded : boolean
		hasChildren : boolean
		parentId : string | null
		originData : UTSJSONObject
		// 方便计算显示
		isShow : boolean
	}
	
	type DragState = {
		startX : number
		startWidth : number
		columnIndex : number
	}

	export default {
		name: "ux-table",
		props: {
			data: {
				type: Array as PropType<UTSJSONObject[]>,
				default: () => [] as UTSJSONObject[]
			},
			columns: {
				type: Array as PropType<UTSJSONObject[]>,
				default: () => [] as UTSJSONObject[]
			}
		},
		data() {
			return {
				allRows: [] as TableRow[],
				selectedRowId: null as string | null,
				columnWidths: [] as number[], // -1 indicates flex, >0 indicates rpx width
				dragState: {
					startX: 0,
					startWidth: 0,
					columnIndex: -1
				} as DragState,
				isAllExpanded: true
			}
		},
		computed: {
			visibleRows() : TableRow[] {
				return this.allRows.filter((row: TableRow) : boolean => {
					return row.isShow
				})
			}
		},
		watch: {
			data: {
				handler(newData : UTSJSONObject[]) {
					this.initTableData(newData)
				},
				deep: true,
				immediate: true
			},
			columns: {
				handler(newCols : UTSJSONObject[]) {
					this.initColumns(newCols)
				},
				deep: true,
				immediate: true
			}
		},
		methods: {
			getColFlex(index: number): string {
				const w = this.columnWidths[index]
				if (w <= 0) return '1'
				return 'none'
			},
			getColWidth(index: number): string {
				const w = this.columnWidths[index]
				if (w <= 0) return ''
				return w + 'rpx'
			},
			initColumns(cols: UTSJSONObject[]) {
				this.columnWidths = cols.map((col): number => {
					const w = col['width']
					if (w != null) {
						// Ensure it is a number. col['width'] from JSON could be various types, assume number
						return Number(w)
					}
					return -1 // Flag for flex
				})
			},
			getStringValue(data : UTSJSONObject, key : string) : string {
				const val = data[key]
				if (val == null) return ''
				return val.toString()
			},
			initTableData(treeData : UTSJSONObject[]) {
				this.allRows = []
				this.flatten(treeData, 0, null)
				// Re-apply current allExpanded state logic if needed, 
				// or just respect the flatten defaults (currently expands all by default)
				// If we want consistency with isAllExpanded flag:
				if (!this.isAllExpanded) {
					// Collapse all if global state is collapsed
					this.allRows.forEach(row => { 
						if(row.hasChildren) row.expanded = false 
					})
					this.refreshVisibility()
				}
			},
			flatten(list : UTSJSONObject[], level : number, parentId : string | null) {
				list.forEach((item, index) => {
					let id = item["id"]
					if (id == null) {
						id = `${parentId}_${index}`
					}
					
					const childrenRaw = item["children"]
					let children: UTSJSONObject[] | null = null
					if (childrenRaw != null && Array.isArray(childrenRaw)) {
						children = childrenRaw as UTSJSONObject[]
					}
					const hasChildren = children != null && children.length > 0
					
					const row : TableRow = {
						id: id.toString(),
						level: level,
						expanded: true, // Default to expanded
						hasChildren: hasChildren,
						parentId: parentId,
						originData: item,
						isShow: true
					}
					
					this.allRows.push(row)
					
					if (hasChildren) {
						this.flatten(children!, level + 1, row.id)
					}
				})
			},
			toggleExpand(row : TableRow) {
				if (!row.hasChildren) return
				row.expanded = !row.expanded
				this.updateChildrenVisibility(row)
				
				// Optional: Check if all are expanded/collapsed to update isAllExpanded
				// For performance, we might skip this or just let it desync slightly.
				// Or simplistic: if any collapsed, isAllExpanded = false.
			},
			toggleAll() {
				this.isAllExpanded = !this.isAllExpanded
				this.allRows.forEach(row => {
					if (row.hasChildren) {
						row.expanded = this.isAllExpanded
					}
				})
				this.refreshVisibility()
			},
			refreshVisibility() {
				// Full refresh of visibility
				// Using Map for faster lookup
				const idMap = new Map<string, TableRow>()
				this.allRows.forEach(r => idMap.set(r.id, r))
				
				this.allRows.forEach(row => {
					if (row.level == 0) {
						row.isShow = true
					} else {
						const parent = idMap.get(row.parentId!)
						if (parent != null && parent.expanded && parent.isShow) {
							row.isShow = true
						} else {
							row.isShow = false
						}
					}
				})
			},
			updateChildrenVisibility(parentRow : TableRow) {
				const startIndex = this.allRows.findIndex((r: TableRow) : boolean => r.id == parentRow.id)
				if (startIndex == -1) return
				
				for (let i = startIndex + 1; i < this.allRows.length; i++) {
					const child = this.allRows[i]
					if (child.level <= parentRow.level) {
						break
					}
					
					if (parentRow.expanded) {
						const pRow = this.findRowById(child.parentId)
						if (pRow != null && pRow.expanded && pRow.isShow) {
							child.isShow = true
						} else {
							child.isShow = false
						}
					} else {
						child.isShow = false
					}
				}
			},
			findRowById(id : string | null) : TableRow | null {
				if (id == null) return null
				return this.allRows.find((r: TableRow) : boolean => r.id == id) || null
			},
			handleRowClick(row : TableRow) {
				this.selectedRowId = row.id
				this.$emit('row-click', row.originData)
			},
			// Drag / Resize Methods
			onResizeStart(index: number, e: TouchEvent) {
				// console.log('Resize Start', index)
				if (e.touches.length == 0) return
				const touch = e.touches[0]
				this.dragState.startX = touch.clientX
				this.dragState.columnIndex = index
				
				let currentW = this.columnWidths[index]
				if (currentW <= 0) {
					// Default start width for flex columns
					currentW = 150
				}
				this.dragState.startWidth = currentW
			},
			onResizeMove(e: TouchEvent) {
				if (this.dragState.columnIndex < 0) return
				if (e.touches.length == 0) return
				
				const touch = e.touches[0]
				const deltaPx = touch.clientX - this.dragState.startX
				
				// Use uni.rpx2px to get the accurate conversion factor
				// 750rpx corresponds to how many pixels currently?
				const screenWidthPx = uni.rpx2px(750)
				const factor = 750 / screenWidthPx
				
				const deltaRpx = deltaPx * factor
				
				// console.log(`Resize Move: deltaPx=${deltaPx}, factor=${factor}, deltaRpx=${deltaRpx}`)
				
				let newWidth = this.dragState.startWidth + deltaRpx
				if (newWidth < 50) newWidth = 50 // Minimum width
				
				// Update
				this.columnWidths[this.dragState.columnIndex] = newWidth
			},
			onResizeEnd() {
				this.dragState.columnIndex = -1
			},
			// #ifdef H5
			onResizeStartMouse(index: number, e: MouseEvent) {
				const startX = e.clientX
				this.dragState.startX = startX
				this.dragState.columnIndex = index
				
				let currentW = this.columnWidths[index]
				if (currentW <= 0) {
					currentW = 150
				}
				this.dragState.startWidth = currentW
				
				// Bind global listeners
				document.addEventListener('mousemove', this.onResizeMoveMouse)
				document.addEventListener('mouseup', this.onResizeEndMouse)
			},
			onResizeMoveMouse(e: MouseEvent) {
				if (this.dragState.columnIndex < 0) return
				
				const deltaPx = e.clientX - this.dragState.startX
				
				// Use uni.rpx2px to get the accurate conversion factor
				const screenWidthPx = uni.rpx2px(750)
				const factor = 750 / screenWidthPx
				const deltaRpx = deltaPx * factor
				
				let newWidth = this.dragState.startWidth + deltaRpx
				if (newWidth < 50) newWidth = 50
				
				this.columnWidths[this.dragState.columnIndex] = newWidth
			},
			onResizeEndMouse() {
				this.dragState.columnIndex = -1
				document.removeEventListener('mousemove', this.onResizeMoveMouse)
				document.removeEventListener('mouseup', this.onResizeEndMouse)
			}
			// #endif
		}
	}
</script>

<style>
	.ux-table {
		display: flex;
		flex-direction: column;
		width: 100%;
		border-width: 1px;
		border-style: solid;
		border-color: #EBEEF5;
	}

	.header {
		background-color: #F5F7FA;
		border-bottom-width: 1px;
		border-bottom-style: solid;
		border-bottom-color: #EBEEF5;
		position: relative; /* Context for absolute positioning */
	}

	.header-row {
		display: flex;
		flex-direction: row;
		/* padding: 20rpx; */ /* Clean up padding to make separators full height */
		height: 80rpx;
		align-items: stretch;
	}

	.header-cell {
		display: flex;
		flex-direction: row;
		align-items: center;
		padding-left: 20rpx;
		padding-right: 40rpx; /* Ensure text stops before the separator line (approx 30rpx from right) */
		position: relative;
		justify-content: flex-start; /* Default align */
		overflow: hidden; /* Clip anything else */
	}

	.header-text {
		font-size: 28rpx;
		font-weight: bold;
		color: #909399;
		flex: 1;
		lines: 1;
		text-overflow: ellipsis;
		overflow: hidden;
	}
	
	.resize-handle {
		position: absolute;
		right: 0;
		top: 0;
		bottom: 0;
		width: 60rpx; /* Increased hit area */
		display: flex;
		flex-direction: row;
		justify-content: center; /* Center the line within the handle area */
		align-items: center;
		cursor: col-resize;
		z-index: 10;
		/* background-color: rgba(255, 0, 0, 0.1); */ /* Debug: visualize hit area */
	}
	
	.separator-line {
		width: 1px;
		height: 40rpx; /* Visible line height */
		background-color: #dcdfe6;
		margin-right: 2px;
	}

	.header-action {
		position: absolute;
		right: 0;
		top: 0;
		bottom: 0;
		width: 120rpx;
		justify-content: center;
		align-items: center;
		background-color: #F5F7FA;
		z-index: 100;
		border-left: 1px solid #dcdfe6;
		box-shadow: -2px 0 5px rgba(0,0,0,0.05);
	}
	
	.header-action-hover {
		background-color: #E6E8EB;
	}
	
	.action-text {
		font-size: 26rpx;
		color: #409EFF;
	}

	.body {
		display: flex;
		flex-direction: column;
	}

	.row {
		display: flex;
		flex-direction: row;
		border-bottom-width: 1px;
		border-bottom-style: solid;
		border-bottom-color: #EBEEF5;
		background-color: #ffffff;
		padding-top: 20rpx;
		padding-bottom: 20rpx;
	}

	.cell {
		display: flex;
		flex-direction: row;
		align-items: center;
		padding-left: 20rpx;
		padding-right: 40rpx; /* Align with header */
		overflow: hidden;
		flex-shrink: 0; 
	}
	
	.cell-content-wrapper {
		display: flex;
		flex-direction: row;
		align-items: center;
		flex: 1; /* Allow content to fill and truncate */
		overflow: hidden;
	}

	.cell-text {
		font-size: 28rpx;
		color: #606266;
		lines: 1;
		text-overflow: ellipsis;
		overflow: hidden;
		flex: 1; /* Ensure text takes space to ellipsis */
	}

	.expand-icon {
		width: 40rpx;
		height: 40rpx;
		justify-content: center;
		align-items: center;
		margin-right: 10rpx;
	}
	
	.icon-text {
		font-size: 24rpx;
		color: #C0C4CC;
	}

	.row-selected {
		background-color: #f0f9eb !important;
	}
</style>
