<template>
	<outsider-layout 
		:initLeftWidth="340" 
		:minLeftWidth="50" 
		:maxLeftWidth="800"
		:initRightWidth="300"
	>
		<template #header>
			<view class="header-container">
				<view class="header-logo">
					<text class="header-text">å·¥è‰ºé¢„è§ˆ (Unified System)</text>
				</view>
				<view class="header-actions">
					<button size="mini" @click="resetData">é‡ç½®</button>
				</view>
			</view>
		</template>

		<template #left>
			<view class="left-panel">
				<ux-table :data="tableData" :columns="columns" @row-click="handleRowClick"></ux-table>
			</view>
		</template>
		<!-- Main Top Area (Dynamic Group) -->
		<view class="main-content-top">
			<view v-if="topGroup != null" style="height: 100%; display: flex; flex-direction: column;">
				<text class="title">{{ topGroup?.name }}</text>
				<ux-tabs :modelValue="activeTabs.get(topGroup?.id ?? '') ?? ''" @update:modelValue="onTabChange(topGroup?.id ?? '', $event)">
					<ux-tab-pane v-for="tab in topGroup!.tabs" :key="tab.id" :label="tab.title" :name="tab.id">
						<scroll-view style="flex: 1; height: 100%;" scroll-y="true">
							<view class="tab-content-wrap">
								<view v-for="comp in tab.components" :key="comp.id" class="component-wrapper">
									<text class="comp-title">{{ comp.title }}</text>
									
									<!-- Table Component -->
									<view v-if="comp.type == 'table'" style="min-height: 200px;">
										<ux-table 
											:columns="getColumnsFromConfig(comp.config)" 
											:data="comp.data"
										></ux-table>
									</view>
									
									<!-- Key-Value Component (Info Panel) -->
									<view v-else-if="comp.type == 'key-value'" class="node-info-panel">
										<text v-for="(field, idx) in getFieldsFromConfig(comp.config)" :key="idx" class="info-row">
											{{ field['label'] }}: {{ getString(comp.data.length > 0 ? comp.data[0] : null, field['key'] as string) }}
										</text>
									</view>
									
									<!-- Text Block Component -->
									<view v-else-if="comp.type == 'text-block'" class="node-info-panel">
										<text class="info-desc">{{ comp.data.length > 0 ? comp.data[0]['text'] : 'æ— æè¿°' }}</text>
									</view>
									
									<!-- List Component -->
									<view v-else-if="comp.type == 'list'" class="list-panel">
										<view v-for="(item, idx) in comp.data" :key="idx" class="list-item-simple">
											<text class="list-item-name">{{ item['text'] }}</text>
										</view>
										<text v-if="comp.data.length == 0" class="empty-hint">æš‚æ— æ•°æ®</text>
									</view>
									
								</view>
							</view>
						</scroll-view>
					</ux-tab-pane>
				</ux-tabs>
			</view>
			
			<view v-else class="loading-state">
				<text>è¯·åœ¨å·¦ä¾§å·¥è‰ºæ ‘ä¸­é€‰æ‹©èŠ‚ç‚¹æŸ¥çœ‹è¯¦æƒ…</text>
			</view>
		</view>
		
		<!-- Main Bottom Area (Dynamic Group) -->
		<template #main-bottom>
			<view class="main-content-bottom">
				<view v-if="bottomGroup != null" style="height: 100%; display: flex; flex-direction: column;">
					<!-- åº•éƒ¨ä½¿ç”¨ Tabs å¯é€‰ï¼Œæˆ–è€…ç›´æ¥æ˜¾ç¤ºç¬¬ä¸€ä¸ª Tab çš„å†…å®¹ -->
					<view class="bottom-header">
						<text class="bottom-title">{{ bottomGroup?.name }}</text>
					</view>
					
					<scroll-view style="flex: 1; height: 100%;" scroll-y="true">
						<view v-if="bottomGroup!.tabs.length > 0" class="bottom-content">
							<!-- æš‚æ—¶åªæ˜¾ç¤ºç¬¬ä¸€ä¸ª Tab çš„æ‰€æœ‰ç»„ä»¶ -->
							<view v-for="comp in bottomGroup!.tabs[0].components" :key="comp.id" class="component-wrapper-simple">
								<text class="comp-title-small" v-if="comp.title != ''">{{ comp.title }}</text>
								
								<!-- Key-Value Component -->
								<view v-if="comp.type == 'key-value'" class="info-grid">
									<view v-for="(field, idx) in getFieldsFromConfig(comp.config)" :key="idx" class="info-item-small">
										<text class="info-label-small">{{ field['label'] }}:</text>
										<text class="info-val-small">{{ getString(comp.data.length > 0 ? comp.data[0] : null, field['key'] as string) }}</text>
									</view>
								</view>
								
								<!-- Text Block Component -->
								<view v-else-if="comp.type == 'text-block'" class="text-block">
									<text class="info-desc-small">{{ comp.data.length > 0 ? comp.data[0]['text'] : 'æ— å†…å®¹' }}</text>
								</view>
							</view>
						</view>
					</scroll-view>
				</view>
				<view v-else class="no-selection">
					<text>é€‰æ‹©èŠ‚ç‚¹æŸ¥çœ‹æ¦‚è§ˆ</text>
				</view>
			</view>
		</template>

		<!-- Right Sidebar Top Area -->
		<template #right>
			<view class="right-panel">
				<view class="right-content">
					<text>Right Panel</text>
				</view>
			</view>
		</template>
		
		<!-- Right Sidebar Bottom Area - é€‰ä¸­èŠ‚ç‚¹è¯¦æƒ… -->
		<template #right-bottom>
			<view class="right-panel-bottom">
				<view v-if="selectedRow != null" class="selected-info">
					<text class="info-title">{{ selectedRow['name'] }}</text>
					<text class="info-type">ç±»å‹: {{ getNodeTypeLabel(selectedRow['type'] as string) }}</text>
					<text class="info-code">ä»£ç : {{ selectedRow['code'] }}</text>
					
					<view v-if="selectedRow['type'] == 'process'" class="info-details">
						<text class="info-item">ç‰ˆæœ¬: {{ selectedRow['version'] }}</text>
						<text class="info-item">çŠ¶æ€: {{ selectedRow['status'] }}</text>
					</view>
					
					<view v-else-if="selectedRow['type'] == 'procedure'" class="info-details">
						<text class="info-item">å·¥æ—¶: {{ selectedRow['duration'] }} åˆ†é’Ÿ</text>
					</view>
					
					<view v-else-if="selectedRow['type'] == 'step'" class="info-details">
						<text class="info-item">å·¥æ—¶: {{ selectedRow['duration'] }} åˆ†é’Ÿ</text>
						<text class="info-item desc-label">æ“ä½œè¯´æ˜:</text>
						<text class="info-desc">{{ selectedRow['description'] }}</text>
					</view>
				</view>
				<view v-else class="no-selection">
					<text>è¯·åœ¨å·¦ä¾§å·¥è‰ºæ ‘ä¸­é€‰æ‹©èŠ‚ç‚¹</text>
				</view>
			</view>
		</template>
	</outsider-layout>
</template>

<script setup lang="uts">
	import { initDatabase, querySQL, executeSQL } from '@/services/database.uts'
	// #ifdef WEB
	import { webGetAll, webGetByIndex, webGetCount } from '@/services/database.uts'
	// #endif
	import { importPackage } from '@/services/dataPackage.uts'
	import { clearAllProcesses } from '@/services/processService.uts'

	import OutsiderLayout from '@/uni_modules/outsider-layout/components/outsider-layout/outsider-layout.uvue'
	import UxTabs from '@/components/ux-tabs/ux-tabs.uvue'
	import UxTabPane from '@/components/ux-tab-pane/ux-tab-pane.uvue'
	import UxTable from '@/components/ux-table/ux-table.uvue'
	import UxCollapse from '@/components/ux-collapse/ux-collapse.uvue'
	import UxCollapseItem from '@/components/ux-collapse-item/ux-collapse-item.uvue'

	// Define ViewModels
	type ComponentVM = {
		id: string
		type: string
		title: string
		config: any // Config can be Array (for table) or Object (for collapse)
		data: UTSJSONObject[]
	}
	
	type TabVM = {
		id: string
		title: string
		components: ComponentVM[]
	}
	
	type GroupVM = {
		id: string
		name: string
		tabs: TabVM[]
	}

	// State
	const leftGroup = ref<GroupVM | null>(null)
	const topGroup = ref<GroupVM | null>(null)
	const bottomGroup = ref<GroupVM | null>(null)
	
	const activeTabs = reactive(new Map<string, string>())
	const statusMessage = ref('Ready')
	
	// Left panel Tree Data (Ref to data in leftGroup for template compatibility)
	const tableData = ref([] as UTSJSONObject[])
	// æ ‘è¡¨åˆ—é…ç½® - å°†ä»æ•°æ®åŒ…ä¸­åŠ è½½ï¼Œæ­¤å¤„ä¸ºé»˜è®¤å€¼
	const columns = ref([
		{ label: 'åç§°', prop: 'displayName', width: 200 },
		{ label: 'èµ„æº', prop: 'resourceLabel', width: 220 }
	] as UTSJSONObject[])
	const selectedRow = ref(null as UTSJSONObject | null)

	onLoad(async () => {
		// console.log('Page Load')
		await initData()
	})
	
	const initData = async () => {
		// #ifdef WEB
		// Web: Check if data exists in IndexedDB
		await initDatabase()
		const count = await webGetCount('meta_tab_groups')
		// #endif
		
		// #ifndef WEB
		// SQL: Check meta_tab_groups table
		await initDatabase()
		const res = await querySQL("SELECT count(*) as count FROM meta_tab_groups")
		const count = res[0]['count'] as number
		// #endif
		
		if (count == 0) {
			statusMessage.value = 'No data found. Please Reset & Import.'
			// console.log('No data found, attempting to load default package if available...')
		} else {
			statusMessage.value = 'Data loaded from DB'
			await loadLeftPanel()
		}
	}
	
	const loadLeftPanel = async () => {
		// Load the "Management" group for the left panel
		// Based on groups.json, id is 'group_process_mgmt'
		const group = await loadGroup('group_process_mgmt')
		if (group != null) {
			leftGroup.value = group
			
			// Load initial data for components in this group (e.g. the Tree)
			await loadDataForGroup(group)
			
			// Bind to template refs for compatibility
			if (group.tabs.length > 0 && group.tabs[0].components.length > 0) {
				const treeComp = group.tabs[0].components[0]
				if (treeComp.type == 'process-tree') {
					tableData.value = treeComp.data
					columns.value = getColumnsFromConfig(treeComp.config)
					// console.log('Left panel tree loaded:', tableData.value.length, 'nodes')
				}
			}
		}
	}
	
	// é€šç”¨ï¼šä¸º Group ä¸­çš„ç»„ä»¶åŠ è½½åˆå§‹æ•°æ® (ç”¨äº static data sources å¦‚å…¨é‡è¡¨)
	const loadDataForGroup = async (group: GroupVM) => {
		for (const tab of group.tabs) {
			for (const comp of tab.components) {
				const config = comp.config as UTSJSONObject
				const dataSource = config['dataSource']
				
				// æ£€æŸ¥æ˜¯å¦é…ç½®äº†æ•°æ®æº
				if (dataSource != null) {
					// Case: { "type": "table", "name": "t_process" }
					if (typeof dataSource == 'object') {
						const dsObj = dataSource as UTSJSONObject
						const dsType = dsObj['type'] as string
						const dsName = dsObj['name'] as string
						
						if (dsType == 'table' && dsName != '') {
							comp.data = await loadTableData(dsName)
							
							// ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯å·¥è‰ºæ ‘ï¼Œéœ€è¦ enrichment
							if (comp.type == 'process-tree') {
								comp.data = comp.data.map((node: UTSJSONObject): UTSJSONObject => enrichNodeForDisplay(node))
							}
						}
					}
				}
			}
		}
	}
	
	// åŠ è½½æ•´è¡¨æ•°æ®
	const loadTableData = async (tableName: string): Promise<UTSJSONObject[]> => {
		let data: UTSJSONObject[] = []
		// #ifdef WEB
		try {
			const rows = await webGetAll(tableName)
			// Web å­˜å‚¨çš„æ˜¯å¯¹è±¡ï¼Œç›´æ¥è½¬æ¢
			data = rows.map((p: any): UTSJSONObject => p as UTSJSONObject)
		} catch (e) { /* console.error('Web load table failed:', tableName, e) */ }
		// #endif
		
		// #ifndef WEB
		try {
			const rows = await querySQL(`SELECT * FROM ${tableName}`)
			data = rows.map((p: UTSJSONObject): UTSJSONObject => {
				// SQL ä¸­ children/data ç­‰å­—æ®µå¯èƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œéœ€è¦å°è¯•è§£æ
				const content = p['data']
				if (content != null && typeof content == 'string') {
					try {
						return JSON.parse(content as string) as UTSJSONObject
					} catch(e) { return p }
				}
				return p
			})
		} catch (e) { console.error('SQL load table failed:', tableName, e) }
		// #endif
		
		return data
	}
	
	// ä¸ºèŠ‚ç‚¹æ·»åŠ æ˜¾ç¤ºå­—æ®µï¼ˆå›¾æ ‡+åç§°ï¼Œèµ„æºè®¡æ•°æ ‡ç­¾ï¼‰
	const enrichNodeForDisplay = (node: UTSJSONObject): UTSJSONObject => {
		// è·å–å›¾æ ‡ï¼Œé»˜è®¤æ ¹æ®ç±»å‹è®¾ç½®
		let icon = node['icon'] as string | null
		if (icon == null) {
			const nodeType = node['type'] as string
			if (nodeType == 'process') icon = 'ğŸ“‹'
			else if (nodeType == 'procedure') icon = 'ğŸ”§'
			else if (nodeType == 'step') icon = 'âš™ï¸'
			else icon = 'ğŸ“„'
		}
		
		// ç”Ÿæˆæ˜¾ç¤ºåç§°: å›¾æ ‡ + åç§°
		const name = node['name'] as string
		node['displayName'] = `${icon} ${name}`
		
		// ç”Ÿæˆèµ„æºè®¡æ•°æ ‡ç­¾: #(æ•°é‡)
		const resourceCount = node['resourceCount']
		if (resourceCount != null) {
			node['resourceLabel'] = `#(${resourceCount})`
		} else {
			node['resourceLabel'] = ''
		}
		
		// é€’å½’å¤„ç†å­èŠ‚ç‚¹
		const children = node['children']
		if (children != null && Array.isArray(children)) {
			const childList = children as UTSJSONObject[]
			for (let i = 0; i < childList.length; i++) {
				enrichNodeForDisplay(childList[i])
			}
		}
		
		return node
	}
	
	const loadGroup = async (groupId: string): Promise<GroupVM | null> => {
		// #ifdef WEB
		return await loadGroupWeb(groupId)
		// #endif
		// #ifndef WEB
		return await loadGroupSQL(groupId)
		// #endif
	}
	
	// #ifdef WEB
	const loadGroupWeb = async (groupId: string): Promise<GroupVM | null> => {
		try {
			const allGroups = await webGetAll('meta_tab_groups')
			const groups = allGroups.filter((g: any) => g.id == groupId)
			if (groups.length == 0) {
				console.log('Web: Group not found:', groupId)
				return null
			}
			
			const groupRow = groups[0]
			const groupVM: GroupVM = {
				id: groupRow.id as string,
				name: groupRow.name as string,
				tabs: []
			}
			
			// Load Tabs
			const allTabs = await webGetByIndex('meta_tabs', 'group_id', groupId)
			const tabs = allTabs.sort((a: any, b: any) => (a.sort_order || 0) - (b.sort_order || 0))
			console.log('Web: Found tabs:', tabs.length)
			
			for (let i = 0; i < tabs.length; i++) {
				const t = tabs[i] as any
				const tabId = t.id as string
				const tabVM: TabVM = {
					id: tabId,
					title: t.title as string,
					components: []
				}
				
				// Load Components
				const allComps = await webGetByIndex('meta_components', 'tab_id', tabId)
				const comps = allComps.sort((a: any, b: any) => (a.sort_order || 0) - (b.sort_order || 0))
				
				for (let j = 0; j < comps.length; j++) {
					const c = comps[j] as any
					const compId = c.id as string
					
					const compVM: ComponentVM = {
						id: compId,
						type: c.type as string,
						title: c.title as string,
						config: c.config,  // Object already parsed in IndexedDB
						data: []
					}
					
					// Load Data
					const records = await webGetByIndex('data_records', 'component_id', compId)
					compVM.data = records.map((r: any): UTSJSONObject => {
						return r.data as UTSJSONObject || {}
					})
					
					tabVM.components.push(compVM)
				}
				
				groupVM.tabs.push(tabVM)
			}
			
			console.log('Web: Group loaded:', groupVM.name, 'with', groupVM.tabs.length, 'tabs')
			return groupVM
		} catch (e) {
			console.error('Web loadGroup error:', e)
			return null
		}
	}
	// #endif
	
	// #ifndef WEB
	const loadGroupSQL = async (groupId: string): Promise<GroupVM | null> => {
		const groups = await querySQL("SELECT * FROM meta_tab_groups WHERE id = ?", [groupId])
		if (groups.length == 0) return null
		
		const groupRow = groups[0]
		const groupVM: GroupVM = {
			id: groupRow['id'] as string,
			name: groupRow['name'] as string,
			tabs: []
		}
		
		// Load Tabs
		const tabs = await querySQL("SELECT * FROM meta_tabs WHERE group_id = ? ORDER BY sort_order", [groupId])
		
		for (let i = 0; i < tabs.length; i++) {
			const t = tabs[i]
			const tabId = t['id'] as string
			const tabVM: TabVM = {
				id: tabId,
				title: t['title'] as string,
				components: []
			}
			
			// Load Components
			const comps = await querySQL("SELECT * FROM meta_components WHERE tab_id = ? ORDER BY sort_order", [tabId])
			for (let j = 0; j < comps.length; j++) {
				const c = comps[j]
				const compId = c['id'] as string
				
				// Parse config
				let config: any = null
				const configStr = c['config_json'] as string
				if (configStr != '') {
					try {
						config = JSON.parse(configStr)
					} catch (e) { console.error('Config parse error', e) }
				}
				
				const compVM: ComponentVM = {
					id: compId,
					type: c['type'] as string,
					title: c['title'] as string,
					config: config,
					data: []
				}
				
				// Load Data
				const records = await querySQL("SELECT data_json FROM data_records WHERE component_id = ?", [compId])
				compVM.data = records.map((r): UTSJSONObject => {
					const jsonStr = r['data_json'] as string
					try {
						return JSON.parse(jsonStr) as UTSJSONObject
					} catch (e) { return {} }
				})
				
				tabVM.components.push(compVM)
			}
			
			groupVM.tabs.push(tabVM)
		}
		
		return groupVM
	}
	// #endif

	
	const onTabChange = (groupId: string, tabId: any) => {
		activeTabs.set(groupId, tabId as string)
	}
	
	const getColumns = (comp: ComponentVM): UTSJSONObject[] => {
		if (Array.isArray(comp.config)) {
			return comp.config as UTSJSONObject[]
		}
		return []
	}
	
	const getCollapseConfig = (comp: ComponentVM): UTSJSONObject => {
		return comp.config as UTSJSONObject
	}
	
	// Helper to get string safely
	const getString = (obj: UTSJSONObject | null, key: string): string => {
		if (obj == null) return ''
		return obj[key]?.toString() ?? ''
	}
	
	const handleRowClick = async (row: UTSJSONObject) => {
		selectedRow.value = row
		// console.log('Row clicked:', row['id'], row['type'], row['name'])
		
		statusMessage.value = `é€‰ä¸­: ${row['name']} (${row['type']})`
		updateSelectedNodeInfo(row)
		
		// æ ¹æ®èŠ‚ç‚¹ç±»å‹åŠ¨æ€åŠ è½½å¯¹åº”çš„ Tab Group
		const nodeType = row['type'] as string
		let groupId = ''
		if (nodeType == 'process') groupId = 'group_process_view'
		else if (nodeType == 'procedure') groupId = 'group_procedure_view'
		else if (nodeType == 'step') groupId = 'group_step_view'
		
		if (groupId != '') {
			const group = await loadGroup(groupId)
			if (group != null) {
				// å°†å½“å‰èŠ‚ç‚¹æ•°æ®ç»‘å®šåˆ° Group çš„ç»„ä»¶ä¸­
				bindDataToGroup(group, row)
				topGroup.value = group
				
				// é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª Tab
				if (!activeTabs.has(group.id) && group.tabs.length > 0) {
					activeTabs.set(group.id, group.tabs[0].id)
				}
			}
		}
		
		// åŠ è½½åº•éƒ¨è¯¦æƒ…
		let bottomGroupId = ''
		if (nodeType == 'process') bottomGroupId = 'group_bottom_proc'
		else if (nodeType == 'procedure') bottomGroupId = 'group_bottom_op'
		else if (nodeType == 'step') bottomGroupId = 'group_bottom_step'
		
		if (bottomGroupId != '') {
			const group = await loadGroup(bottomGroupId)
			if (group != null) {
				bindDataToGroup(group, row)
				bottomGroup.value = group
			}
		}
	}
	
	// å°†èŠ‚ç‚¹æ•°æ®ç»‘å®šåˆ° Group ä¸­çš„å„ä¸ªç»„ä»¶
	const bindDataToGroup = (group: GroupVM, node: UTSJSONObject) => {
		for (let i = 0; i < group.tabs.length; i++) {
			const tab = group.tabs[i]
			for (let j = 0; j < tab.components.length; j++) {
				const comp = tab.components[j]
				const config = comp.config as UTSJSONObject
				const dataSource = config['dataSource'] as string
				
				// æ ¹æ® dataSource å¡«å…… comp.data
				comp.data = [] // Reset
				
				if (dataSource == 'self') {
					// è‡ªèº«æ•°æ®ï¼Œä½œä¸ºå•æ¡è®°å½•æ”¾å…¥æ•°ç»„
					comp.data.push(node)
				} else if (dataSource == 'children') {
					// å­èŠ‚ç‚¹åˆ—è¡¨
					const children = node['children']
					if (children != null && Array.isArray(children)) {
						const list = children as UTSJSONObject[]
						// ç¡®ä¿å­èŠ‚ç‚¹ä¹Ÿæœ‰æ˜¾ç¤ºç”¨å­—æ®µ
						comp.data = list.map((c: UTSJSONObject): UTSJSONObject => enrichNodeForDisplay(c))
					}
				} else if (dataSource == 'description') {
					// æè¿°æ–‡æœ¬ï¼ŒåŒ…è£…æˆå¯¹è±¡
					const desc = node['description']
					if (desc != null) {
						const item = { text: desc }
						comp.data.push(item)
					}
				} else if (dataSource == 'tools') {
					// å·¥å…·åˆ—è¡¨
					const tools = node['tools']
					if (tools != null && Array.isArray(tools)) {
						const list = tools as string[]
						comp.data = list.map((t: string): UTSJSONObject => {
							return { text: t }
						})
					}
				} else if (dataSource == 'materials') {
					// ç‰©æ–™åˆ—è¡¨
					const materials = node['materials']
					if (materials != null && Array.isArray(materials)) {
						const list = materials as string[]
						comp.data = list.map((m: string): UTSJSONObject => {
							return { text: m }
						})
					}
				}
			}
		}
	}
	
	// ä» config ä¸­æå– columns (ç”¨äºè¡¨æ ¼)
	const getColumnsFromConfig = (config: any): UTSJSONObject[] => {
		if (config == null) return []
		const confObj = config as UTSJSONObject
		// æ£€æŸ¥æ˜¯å¦æœ‰ columns å­—æ®µ (æ–°çš„ç»“æ„)
		if (confObj['columns'] != null) {
			const cols = confObj['columns']
			if (Array.isArray(cols)) return cols as UTSJSONObject[]
		}
		// å…¼å®¹æ—§ç»“æ„ (configæœ¬èº«å°±æ˜¯æ•°ç»„)
		if (Array.isArray(config)) return config as UTSJSONObject[]
		return []
	}
	
	// ä» config ä¸­æå– fields (ç”¨äº Key-Value)
	const getFieldsFromConfig = (config: any): UTSJSONObject[] => {
		if (config == null) return []
		const confObj = config as UTSJSONObject
		if (confObj['fields'] != null) {
			const fields = confObj['fields']
			if (Array.isArray(fields)) return fields as UTSJSONObject[]
		}
		return []
	}
	
	// è·å–èŠ‚ç‚¹ç±»å‹çš„ä¸­æ–‡æ ‡ç­¾
	const getNodeTypeLabel = (nodeType: string): string => {
		if (nodeType == 'process') return 'å·¥è‰º'
		if (nodeType == 'procedure') return 'å·¥åº'
		if (nodeType == 'step') return 'å·¥æ­¥'
		return nodeType
	}
	
	// æ›´æ–°é€‰ä¸­èŠ‚ç‚¹çš„è¯¦ç»†ä¿¡æ¯ (ä»…ç”¨äºæ—¥å¿—)
	const updateSelectedNodeInfo = (node: UTSJSONObject) => {
		/*
		const nodeType = node['type'] as string
		if (nodeType == 'process') {
			console.log('Selected process:', node['name'])
		} else if (nodeType == 'procedure') {
			console.log('Selected procedure:', node['name'])
		} else if (nodeType == 'step') {
			console.log('Selected step:', node['name'])
		}
		*/
	}
	
	const resetData = async () => {
		statusMessage.value = 'Resetting...'
		
		// 1. Clear UI tables
		await executeSQL("DELETE FROM meta_tab_groups")
		await executeSQL("DELETE FROM meta_tabs")
		await executeSQL("DELETE FROM meta_components")
		await executeSQL("DELETE FROM data_records")
		
		// 2. Clear Process tables
		await clearAllProcesses()
		
		uni.showToast({ title: 'Data cleared' })
		topGroup.value = null
		bottomGroup.value = null
		
		// 3. Re-init to trigger generation
		await initData()
	}

</script>

<style>
	.header-container {
		height: 60px;
		background-color: #fff;
		border-bottom: 1px solid #e0e0e0;
		display: flex;
		flex-direction: row;
		align-items: center;
		padding: 0 20px;
		justify-content: space-between;
	}
	
	.header-logo {
		padding: 5px 10px;
		background-color: #f0f0f0;
		border-radius: 4px;
	}
	
	.header-actions {
		padding: 5px 10px;
	}
	
	.header-text {
		font-weight: bold;
		font-size: 14px;
	}

	.left-panel {
		flex: 1;
		display: flex;
		flex-direction: column;
		height: 100%;
		background-color: #fff;
		min-width: 0;
	}
	
	.main-content-top {
		padding: 20px;
		display: flex;
		flex-direction: column;
		flex: 1;
	}
	
	.main-content-bottom {
		padding: 20px;
		display: flex;
		flex-direction: column;
		background-color: #fafafa;
		height: 100px; /* Fixed height for bottom area demo */
	}

	.title {
		font-size: 24px;
		font-weight: bold;
		margin-bottom: 20px;
	}

	.right-panel {
		width: 250px;
		height: 100%;
		border-left: 1px solid #e0e0e0;
		background-color: #fff;
		display: flex;
		flex-direction: column;
	}

	.right-content {
		padding: 15px;
		display: flex;
		flex-direction: column;
	}
	
	.right-panel-bottom {
		padding: 10px;
		background-color: #fafafa;
		display: flex;
		flex-direction: column;
		height: 100%;
	}
	
	.tab-content-wrap {
		padding: 10px 0;
	}
	
	.component-wrapper {
		margin-bottom: 20px;
		padding: 10px;
		border: 1px solid #eee;
		border-radius: 6rpx;
	}
	
	.comp-title {
		font-weight: bold;
		margin-bottom: 10px;
		font-size: 16px;
		display: block;
	}
	
	.kv-row {
		display: block;
		margin-bottom: 5px;
		font-size: 14px;
		color: #555;
	}
	
	.loading-state {
		display: flex;
		justify-content: center;
		padding: 20px;
		color: #999;
	}
	
	/* é€‰ä¸­èŠ‚ç‚¹è¯¦æƒ…æ ·å¼ */
	.selected-info {
		padding: 15px;
		display: flex;
		flex-direction: column;
	}
	
	.info-title {
		font-size: 18px;
		font-weight: bold;
		color: #333;
		margin-bottom: 10px;
	}
	
	.info-type {
		font-size: 14px;
		color: #666;
		margin-bottom: 5px;
	}
	
	.info-code {
		font-size: 14px;
		color: #888;
		margin-bottom: 10px;
	}
	
	.info-details {
		padding-top: 10px;
		border-top-width: 1px;
		border-top-style: solid;
		border-top-color: #eee;
	}
	
	.info-item {
		font-size: 14px;
		color: #555;
		margin-bottom: 5px;
	}
	
	.desc-label {
		color: #666;
		margin-top: 10px;
	}
	
	.info-desc {
		font-size: 14px;
		color: #333;
		line-height: 1.5;
	}
	
	.no-selection {
		display: flex;
		justify-content: center;
		align-items: center;
		height: 100%;
		color: #999;
		font-size: 14px;
	}
	
	/* ä¸­é—´åŒºåŸŸèŠ‚ç‚¹ä¿¡æ¯æ ·å¼ */
	.node-info-panel {
		padding: 15px;
		display: flex;
		flex-direction: column;
	}
	
	.info-row {
		font-size: 14px;
		color: #333;
		margin-bottom: 8px;
	}
	
	.info-label {
		font-size: 14px;
		color: #666;
		margin-top: 15px;
		margin-bottom: 5px;
	}
	
	/* åº•éƒ¨åŒºåŸŸæ ·å¼ */
	.bottom-header {
		padding-bottom: 5px;
		border-bottom: 1px solid #eee;
		margin-bottom: 5px;
	}
	
	.bottom-title {
		font-size: 16px;
		font-weight: bold;
		color: #333;
	}
	
	.component-wrapper-simple {
		padding: 5px 0;
	}
	
	.comp-title-small {
		font-size: 13px;
		color: #999;
		margin-bottom: 5px;
	}
	
	.info-grid {
		display: flex;
		flex-direction: row;
		flex-wrap: wrap;
	}
	
	.info-item-small {
		display: flex;
		flex-direction: row;
		margin-right: 20px;
		margin-bottom: 5px;
		align-items: center;
	}
	
	.info-label-small {
		font-size: 13px;
		color: #888;
		margin-right: 5px;
	}
	
	.info-val-small {
		font-size: 14px;
		color: #333;
		font-weight: 500;
	}
	
	.info-desc-small {
		font-size: 13px;
		color: #666;
		line-height: 1.4;
	}
	
	/* åˆ—è¡¨é¢æ¿æ ·å¼ */
	.list-panel {
		padding: 10px;
	}
	
	.list-item {
		display: flex;
		flex-direction: row;
		align-items: center;
		padding: 12px 15px;
		background-color: #fff;
		border-radius: 6px;
		margin-bottom: 8px;
		border: 1px solid #e8e8e8;
	}
	
	.list-item-code {
		font-size: 13px;
		color: #888;
		width: 120px;
	}
	
	.list-item-name {
		font-size: 14px;
		color: #333;
		flex: 1;
	}
	
	.list-item-duration {
		font-size: 13px;
		color: #666;
		width: 80px;
	}
	
	.list-item-simple {
		padding: 10px 15px;
		background-color: #f9f9f9;
		border-radius: 4px;
		margin-bottom: 6px;
	}
	
	.empty-hint {
		text-align: center;
		color: #999;
		font-size: 14px;
		padding: 20px;
	}
</style>

