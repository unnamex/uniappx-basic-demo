<template>
	<outsider-layout 
		:initLeftWidth="340" 
		:minLeftWidth="50" 
		:maxLeftWidth="800"
		:initRightWidth="300"
		:initRightTopHeight="500"
		:minRightTopHeight="200"
	>
		<template #header>
			<view class="header-container">
				<view class="header-logo">
					<text class="header-text">å·¥è‰ºé¢„è§ˆ (Unified System)</text>
				</view>
				<view class="header-actions">
					<button size="mini" @click="resetData">é‡ç½®</button>
				</view>
			</view>
		</template>

		<template #left>
			<view class="left-panel">
				<ux-table :data="tableData" :columns="columns" @row-click="handleRowClick"></ux-table>
			</view>
		</template>
		<!-- Main Top Area (Dynamic Group) -->
		<view class="main-content-top">
			<view v-if="topGroup != null" style="height: 100%; display: flex; flex-direction: column;">
				<text class="title">{{ topGroup?.name }}</text>
				<ux-tabs :modelValue="activeTabs.get(topGroup?.id ?? '') ?? ''" @update:modelValue="onTabChange(topGroup?.id ?? '', $event)">
					<ux-tab-pane v-for="tab in topGroup!.tabs" :key="tab.id" :label="tab.title" :name="tab.id">
						<scroll-view style="flex: 1; height: 100%;" scroll-y="true">
							<view class="tab-content-wrap">
								<view v-for="comp in tab.components" :key="comp.id" class="component-wrapper">
									<text class="comp-title">{{ comp.title }}</text>
									
									<!-- Table Component -->
									<view v-if="comp.type == 'table'" style="min-height: 200px;">
										<ux-table 
											:columns="getColumnsFromConfig(comp.config)" 
											:data="comp.data"
										></ux-table>
									</view>
									
									<!-- Key-Value Component (Info Panel) -->
									<view v-else-if="comp.type == 'key-value'" class="node-info-panel">
										<text v-for="(field, idx) in getFieldsFromConfig(comp.config)" :key="idx" class="info-row">
											{{ field['label'] }}: {{ getString(comp.data.length > 0 ? comp.data[0] : null, field['key'] as string) }}
										</text>
									</view>
									
									<!-- Text Block Component -->
									<view v-else-if="comp.type == 'text-block'" class="node-info-panel">
										<text class="info-desc">{{ comp.data.length > 0 ? comp.data[0]['text'] : 'æ— æè¿°' }}</text>
									</view>
									
									<!-- List Component -->
									<view v-else-if="comp.type == 'list'" class="list-panel">
										<view v-for="(item, idx) in comp.data" :key="idx" class="list-item-simple">
											<text class="list-item-name">{{ item['text'] }}</text>
										</view>
										<text v-if="comp.data.length == 0" class="empty-hint">æš‚æ— æ•°æ®</text>
									</view>
									
								</view>
							</view>
						</scroll-view>
					</ux-tab-pane>
				</ux-tabs>
			</view>
			
			<view v-else class="loading-state">
				<text>è¯·åœ¨å·¦ä¾§å·¥è‰ºæ ‘ä¸­é€‰æ‹©èŠ‚ç‚¹æŸ¥çœ‹è¯¦æƒ…</text>
			</view>
		</view>
		
		<!-- Main Bottom Area (Dynamic Group) -->
		<template #main-bottom>
			<view class="main-content-bottom">
				<view v-if="bottomGroup != null" style="height: 100%; display: flex; flex-direction: column;">
					<!-- åº•éƒ¨ä½¿ç”¨ Tabs å¯é€‰ï¼Œæˆ–è€…ç›´æ¥æ˜¾ç¤ºç¬¬ä¸€ä¸ª Tab çš„å†…å®¹ -->
					<view class="bottom-header">
						<text class="bottom-title">{{ bottomGroup?.name }}</text>
					</view>
					
					<scroll-view style="flex: 1; height: 100%;" scroll-y="true">
						<view v-if="bottomGroup!.tabs.length > 0" class="bottom-content">
							<!-- æš‚æ—¶åªæ˜¾ç¤ºç¬¬ä¸€ä¸ª Tab çš„æ‰€æœ‰ç»„ä»¶ -->
							<view v-for="comp in bottomGroup!.tabs[0].components" :key="comp.id" class="component-wrapper-simple">
								<text class="comp-title-small" v-if="comp.title != ''">{{ comp.title }}</text>
								
								<!-- Key-Value Component -->
								<view v-if="comp.type == 'key-value'" class="info-grid">
									<view v-for="(field, idx) in getFieldsFromConfig(comp.config)" :key="idx" class="info-item-small">
										<text class="info-label-small">{{ field['label'] }}:</text>
										<text class="info-val-small">{{ getString(comp.data.length > 0 ? comp.data[0] : null, field['key'] as string) }}</text>
									</view>
								</view>
								
								<!-- Text Block Component -->
								<view v-else-if="comp.type == 'text-block'" class="text-block">
									<text class="info-desc-small">{{ comp.data.length > 0 ? comp.data[0]['text'] : 'æ— å†…å®¹' }}</text>
								</view>
							</view>
						</view>
					</scroll-view>
				</view>
				<view v-else class="no-selection">
					<text>é€‰æ‹©èŠ‚ç‚¹æŸ¥çœ‹æ¦‚è§ˆ</text>
				</view>
			</view>
		</template>

		<!-- Right Sidebar Top Area - èµ„æºé¢„è§ˆ -->
		<template #right>
			<view class="right-panel">
				<!-- å³ä¾§åŒºåŸŸå¤´éƒ¨ -->
				<view class="right-header">
					<text class="right-header-title">æŸ¥çœ‹å™¨</text>
					<view class="right-header-btn" @click="toggleResourceMaximize">
						<text class="btn-icon">{{ isResourceMaximized ? 'â¤¡' : 'â¤¢' }}</text>
					</view>
				</view>
				<resource-preview :resource="previewResource" @error="onPreviewError" />
			</view>
		</template>
		
		<!-- Right Sidebar Bottom Area - èµ„æºåˆ—è¡¨ -->
		<template #right-bottom>
			<view class="right-panel-bottom">
				<resource-list 
					:title="nodeResourcesTitle"
					:resources="nodeResources"
					:selectedId="previewResource != null ? previewResource.id : ''"
					@select="onResourceSelect"
				/>
			</view>
		</template>
	</outsider-layout>
	
	<!-- å…¨å±èµ„æºé¢„è§ˆè¦†ç›–å±‚ -->
	<view v-if="isResourceMaximized" class="resource-fullscreen-overlay">
		<view class="fullscreen-container">
			<!-- å¤´éƒ¨å·¥å…·æ  -->
			<view class="fullscreen-header">
				<view class="header-left">
					<text class="fullscreen-title">{{ nodeResourcesTitle }}</text>
					<text v-if="nodeResources.length > 0" class="resource-counter">{{ currentResourceIndex + 1 }} / {{ nodeResources.length }}</text>
				</view>
				<view class="header-actions">
					<!-- åˆ—è¡¨æ˜¾ç¤º/éšè—æŒ‰é’® -->
					<view class="header-btn" @click="toggleFullscreenList">
						<text class="header-btn-icon">{{ isFullscreenListVisible ? 'â—§' : 'â˜°' }}</text>
					</view>
					<!-- å…³é—­æŒ‰é’® -->
					<view class="fullscreen-close" @click="toggleResourceMaximize">
						<text class="close-icon">âœ•</text>
					</view>
				</view>
			</view>
			
			<!-- å†…å®¹åŒºåŸŸ -->
			<view class="fullscreen-content">
				<!-- é¢„è§ˆåŒºï¼ˆå¯å æ»¡æˆ–ä¸åˆ—è¡¨å…±å­˜ï¼‰ -->
				<view class="fullscreen-preview" :class="{ 'preview-full': !isFullscreenListVisible }">
					<!-- ä¸Šä¸€ä¸ª/ä¸‹ä¸€ä¸ªå¯¼èˆªæŒ‰é’® -->
					<view v-if="nodeResources.length > 1" class="nav-btn nav-prev" @click="goPrevResource">
						<text class="nav-icon">â€¹</text>
					</view>
					
					<!-- å›¾ç‰‡ç±»å‹ï¼šè‡ªå®šä¹‰å¯å˜æ¢é¢„è§ˆ -->
					<view v-if="previewResource != null && previewResource.type == 'image'" class="image-viewer-container">
						<scroll-view 
							scroll-x="true" 
							scroll-y="true" 
							class="image-scroll-view"
						>
							<view class="image-transform-wrapper" :style="imageTransformStyle">
								<image 
									class="fullscreen-image" 
									:src="previewResource.path" 
									mode="aspectFit"
									@load="onFullscreenImageLoad"
								/>
							</view>
						</scroll-view>
						
						<!-- å›¾ç‰‡æ“ä½œå·¥å…·æ  -->
						<view class="image-toolbar">
							<view class="toolbar-btn" @click="imageZoomOut">
								<text class="toolbar-icon">âˆ’</text>
								<text class="toolbar-label">ç¼©å°</text>
							</view>
							<view class="toolbar-info">
								<text class="zoom-percentage">{{ Math.round(imageScale * 100) }}%</text>
							</view>
							<view class="toolbar-btn" @click="imageZoomIn">
								<text class="toolbar-icon">+</text>
								<text class="toolbar-label">æ”¾å¤§</text>
							</view>
							<view class="toolbar-divider"></view>
							<view class="toolbar-btn" @click="imageRotateLeft">
								<text class="toolbar-icon">â†º</text>
								<text class="toolbar-label">å·¦æ—‹</text>
							</view>
							<view class="toolbar-btn" @click="imageRotateRight">
								<text class="toolbar-icon">â†»</text>
								<text class="toolbar-label">å³æ—‹</text>
							</view>
							<view class="toolbar-divider"></view>
							<view class="toolbar-btn" @click="imageReset">
								<text class="toolbar-icon">âŸ²</text>
								<text class="toolbar-label">é‡ç½®</text>
							</view>
						</view>
					</view>
					
					<!-- éå›¾ç‰‡ç±»å‹ï¼šä½¿ç”¨åŸç»„ä»¶ -->
					<resource-preview v-else :resource="previewResource" @error="onPreviewError" />
					
					<view v-if="nodeResources.length > 1" class="nav-btn nav-next" @click="goNextResource">
						<text class="nav-icon">â€º</text>
					</view>
				</view>
				
				<!-- å³ä¾§ç¼©ç•¥å›¾åˆ—è¡¨ï¼ˆå¯éšè—ï¼‰ -->
				<view v-if="isFullscreenListVisible" class="fullscreen-list">
					<scroll-view scroll-y="true" style="flex: 1;">
						<view class="fullscreen-list-inner">
							<view 
								v-for="(item, index) in nodeResources" 
								:key="item.id"
								class="fullscreen-thumb-item"
								:class="{ 'selected': previewResource != null && previewResource.id == item.id }"
								@click="onResourceSelect(item)"
							>
								<view class="thumb-wrapper">
									<image 
										v-if="item.type == 'image'" 
										class="thumb-img"
										:src="item.thumbnail != '' ? item.thumbnail : item.path"
										mode="aspectFill"
									/>
									<text v-else-if="item.type == 'video'" class="thumb-icon">ğŸ¬</text>
									<text v-else-if="item.type == 'audio'" class="thumb-icon">ğŸµ</text>
									<text v-else class="thumb-icon">ğŸ“„</text>
								</view>
								<text class="thumb-name" :numberOfLines="1">{{ item.name }}</text>
							</view>
						</view>
					</scroll-view>
				</view>
			</view>
		</view>
	</view>
</template>

<script setup lang="uts">
	import { onLoad, onShow } from '@dcloudio/uni-app'
	import { initDatabase, querySQL, executeSQL } from '@/services/database.uts'
	// #ifdef WEB
	import { webGetAll, webGetByIndex, webGetCount, webClearStore } from '@/services/database.uts'
	// #endif
	import { importPackage } from '@/services/dataPackage.uts'
	import { clearAllProcesses } from '@/services/processService.uts'
	import { ResourceItem } from '@/types/resource'
	import { getResourcesByNodeId, clearAllResources } from '@/services/resourceService.uts'

	import OutsiderLayout from '@/uni_modules/outsider-layout/components/outsider-layout/outsider-layout.uvue'
	import UxTabs from '@/components/ux-tabs/ux-tabs.uvue'
	import UxTabPane from '@/components/ux-tab-pane/ux-tab-pane.uvue'
	import UxTable from '@/components/ux-table/ux-table.uvue'
	import UxCollapse from '@/components/ux-collapse/ux-collapse.uvue'
	import UxCollapseItem from '@/components/ux-collapse-item/ux-collapse-item.uvue'
	import ResourcePreview from '@/components/resource-preview/resource-preview.uvue'
	import ResourceList from '@/components/resource-list/resource-list.uvue'

	// Define ViewModels
	type ComponentVM = {
		id: string
		type: string
		title: string
		config: any // Config can be Array (for table) or Object (for collapse)
		data: UTSJSONObject[]
	}
	
	type TabVM = {
		id: string
		title: string
		components: ComponentVM[]
	}
	
	type GroupVM = {
		id: string
		name: string
		tabs: TabVM[]
	}

	// State
	const leftGroup = ref<GroupVM | null>(null)
	const topGroup = ref<GroupVM | null>(null)
	const bottomGroup = ref<GroupVM | null>(null)
	
	const activeTabs = reactive(new Map<string, string>())
	const statusMessage = ref('Ready')
	
	// Left panel Tree Data (Ref to data in leftGroup for template compatibility)
	const tableData = ref([] as UTSJSONObject[])
	// æ ‘è¡¨åˆ—é…ç½® - å°†ä»æ•°æ®åŒ…ä¸­åŠ è½½ï¼Œæ­¤å¤„ä¸ºé»˜è®¤å€¼
	const columns = ref([] as UTSJSONObject[])
	const selectedRow = ref(null as UTSJSONObject | null)
	
	// èµ„æºé¢„è§ˆç›¸å…³çŠ¶æ€
	const nodeResources = ref([] as ResourceItem[])
	const nodeResourcesTitle = ref('èµ„æºåˆ—è¡¨')
	const previewResource = ref(null as ResourceItem | null)
	const isResourceMaximized = ref(false)
	const isFullscreenListVisible = ref(true)
	
	// å½“å‰èµ„æºç´¢å¼•
	const currentResourceIndex = computed((): number => {
		if (previewResource.value == null) return 0
		const idx = nodeResources.value.findIndex((r: ResourceItem): boolean => r.id == previewResource.value!.id)
		return idx >= 0 ? idx : 0
	})
	
	// å›¾ç‰‡å˜æ¢çŠ¶æ€
	const imageScale = ref(1)
	const imageRotation = ref(0)
	
	// å›¾ç‰‡å˜æ¢æ ·å¼
	const imageTransformStyle = computed((): string => {
		return `transform: scale(${imageScale.value}) rotate(${imageRotation.value}deg);`
	})

	onLoad(async () => {
		// console.log('Page Load')
		await initData()
	})
	
	onShow(async () => {
		// æ¯æ¬¡é¡µé¢æ˜¾ç¤ºæ—¶æ£€æŸ¥å¹¶åˆ·æ–°æ•°æ®
		// console.log('Page Show')
		await initData()
	})
	
	const initData = async () => {
		// #ifdef WEB
		// Web: Check if data exists in IndexedDB
		await initDatabase()
		const count = await webGetCount('meta_tab_groups')
		// #endif
		
		// #ifndef WEB
		// SQL: Check meta_tab_groups table
		await initDatabase()
		const res = await querySQL("SELECT count(*) as count FROM meta_tab_groups")
		const count = res[0]['count'] as number
		// #endif
		
		if (count == 0) {
			statusMessage.value = 'No data found. Please Reset & Import.'
			// console.log('No data found, attempting to load default package if available...')
		} else {
			statusMessage.value = 'Data loaded from DB'
			await loadLeftPanel()
		}
	}
	
	// é‡ç½®æ•°æ® - åªæ¸…ç©ºæ•°æ®åº“å­˜å‚¨
	const resetData = async () => {
		try {
			uni.showLoading({ title: 'é‡ç½®ä¸­...' })
			
			// #ifdef WEB
			console.log('Resetting all data...')
			await webClearStore('meta_tab_groups')
			await webClearStore('meta_tabs')
			await webClearStore('meta_components')
			await webClearStore('data_records')
			await webClearStore('t_process')
			await webClearStore('t_icon_config')
			await webClearStore('t_resources')  // V3: æ¸…ç©ºèµ„æºè¡¨
			console.log('All data cleared')
			// #endif
			
			// #ifndef WEB
			await executeSQL('DELETE FROM meta_tab_groups')
			await executeSQL('DELETE FROM meta_tabs')
			await executeSQL('DELETE FROM meta_components')
			await executeSQL('DELETE FROM data_records')
			await executeSQL('DELETE FROM t_process')
			await executeSQL('DELETE FROM t_icon_config')
			await executeSQL('DELETE FROM t_resources')  // V3: æ¸…ç©ºèµ„æºè¡¨
			// #endif
			
			// æ¸…ç†èµ„æºæ–‡ä»¶ï¼ˆä»… App ç«¯ï¼‰
			await clearAllResources()
			
			// æ¸…ç©º UI çŠ¶æ€
			leftGroup.value = null
			topGroup.value = null
			bottomGroup.value = null
			tableData.value = []
			selectedRow.value = null
			iconConfigs.clear()
			activeTabs.clear()
			
			// æ¸…ç©ºèµ„æºçŠ¶æ€
			nodeResources.value = []
			nodeResourcesTitle.value = 'èµ„æºåˆ—è¡¨'
			previewResource.value = null
			
			uni.hideLoading()
			uni.showToast({
				title: 'æ•°æ®å·²æ¸…ç©º',
				icon: 'success'
			})
		} catch (e) {
			uni.hideLoading()
			console.error('Reset failed:', e)
			uni.showToast({
				title: 'é‡ç½®å¤±è´¥',
				icon: 'none'
			})
		}
	}
	
	const loadLeftPanel = async () => {
		// Load the "Management" group for the left panel
		// Based on groups.json, id is 'group_process_mgmt'
		const group = await loadGroup('group_process_mgmt')
		if (group != null) {
			leftGroup.value = group
			
			// Load icon configurations first
			await loadIconConfigs()
			
			// Load initial data for components in this group (e.g. the Tree)
			await loadDataForGroup(group)
			
			// Bind to template refs for compatibility
			if (group.tabs.length > 0 && group.tabs[0].components.length > 0) {
				const treeComp = group.tabs[0].components[0]
				if (treeComp.type == 'process-tree') {
					tableData.value = treeComp.data
					columns.value = getColumnsFromConfig(treeComp.config)
					// console.log('Left panel tree loaded:', tableData.value.length, 'nodes')
					
					// è‡ªåŠ¨é€‰ä¸­ç¬¬ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼ˆå·¥è‰ºèŠ‚ç‚¹ï¼‰
					if (tableData.value.length > 0) {
						const firstRow = tableData.value[0]
						// å»¶è¿Ÿæ‰§è¡Œç¡®ä¿ UI æ¸²æŸ“å®Œæˆ
						setTimeout(() => {
							handleRowClick(firstRow)
						}, 100)
					}
				}
			}
		}
	}
	
	// é€šç”¨ï¼šä¸º Group ä¸­çš„ç»„ä»¶åŠ è½½åˆå§‹æ•°æ® (ç”¨äº static data sources å¦‚å…¨é‡è¡¨)
	const loadDataForGroup = async (group: GroupVM) => {
		for (const tab of group.tabs) {
			for (const comp of tab.components) {
				const config = comp.config as UTSJSONObject
				const dataSource = config['dataSource']
				
				// æ£€æŸ¥æ˜¯å¦é…ç½®äº†æ•°æ®æº
				if (dataSource != null) {
					// Case: { "type": "table", "name": "t_process" }
					if (typeof dataSource == 'object') {
						const dsObj = dataSource as UTSJSONObject
						const dsType = dsObj['type'] as string
						const dsName = dsObj['name'] as string
						
						if (dsType == 'table' && dsName != '') {
							comp.data = await loadTableData(dsName)
							
							// ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯å·¥è‰ºæ ‘ï¼Œéœ€è¦ enrichment
							if (comp.type == 'process-tree') {
								comp.data = comp.data.map((node: UTSJSONObject): UTSJSONObject => enrichNodeForDisplay(node))
							}
						}
					}
				}
			}
		}
	}
	
	// åŠ è½½æ•´è¡¨æ•°æ®
	const loadTableData = async (tableName: string): Promise<UTSJSONObject[]> => {
		let data: UTSJSONObject[] = []
		// #ifdef WEB
		try {
			const rows = await webGetAll(tableName)
			// Web å­˜å‚¨çš„æ˜¯å¯¹è±¡ï¼Œç›´æ¥è½¬æ¢
			data = rows.map((p: any): UTSJSONObject => p as UTSJSONObject)
		} catch (e) { /* console.error('Web load table failed:', tableName, e) */ }
		// #endif
		
		// #ifndef WEB
		try {
			const rows = await querySQL(`SELECT * FROM ${tableName}`)
			data = rows.map((p: UTSJSONObject): UTSJSONObject => {
				// SQL ä¸­ children/data ç­‰å­—æ®µå¯èƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œéœ€è¦å°è¯•è§£æ
				const content = p['data']
				if (content != null && typeof content == 'string') {
					try {
						return JSON.parse(content as string) as UTSJSONObject
					} catch(e) { return p }
				}
				return p
			})
		} catch (e) { console.error('SQL load table failed:', tableName, e) }
		// #endif
		
		return data
	}
	
	// å›¾æ ‡é…ç½®ç¼“å­˜ (node_type -> { icon_name, fallback })
	const iconConfigs = reactive(new Map<string, UTSJSONObject>())
	
	// åŠ è½½å›¾æ ‡é…ç½®
	const loadIconConfigs = async () => {
		// #ifdef WEB
		try {
			const configs = await webGetAll('t_icon_config')
			for (const cfg of configs) {
				const nodeType = cfg['node_type'] as string
				iconConfigs.set(nodeType, cfg as UTSJSONObject)
			}
			console.log('Loaded icon configs:', iconConfigs.size)
		} catch (e) {
			console.error('Failed to load icon configs:', e)
		}
		// #endif
	}
	
	// è·å–å›¾æ ‡è·¯å¾„ï¼ˆåŸºäº static/icons/ ç›®å½•ï¼‰
	const getIconPath = (iconName: string): string => {
		return `/static/icons/${iconName}.svg`
	}
	
	// ä¸ºèŠ‚ç‚¹æ·»åŠ æ˜¾ç¤ºå­—æ®µï¼ˆå›¾æ ‡+åç§°ï¼Œèµ„æºè®¡æ•°æ ‡ç­¾ï¼‰
	const enrichNodeForDisplay = (node: UTSJSONObject): UTSJSONObject => {
		// è·å–å›¾æ ‡é…ç½®
		let fallbackEmoji = 'ğŸ“„'
		let iconName = 'default'
		
		const nodeType = node['type'] as string
		const cfg = iconConfigs.get(nodeType) ?? iconConfigs.get('default')
		
		if (cfg != null) {
			iconName = cfg['icon_name'] as string ?? nodeType
			fallbackEmoji = cfg['fallback'] as string ?? 'ğŸ“„'
		} else {
			// é»˜è®¤é…ç½®
			if (nodeType == 'process') { iconName = 'process'; fallbackEmoji = 'ğŸ“‹' }
			else if (nodeType == 'procedure') { iconName = 'procedure'; fallbackEmoji = 'ğŸ”§' }
			else if (nodeType == 'step') { iconName = 'step'; fallbackEmoji = 'âš™ï¸' }
		}
		
		// å­˜å‚¨å›¾æ ‡è·¯å¾„ï¼ˆç”¨äºéœ€è¦æ˜¾ç¤ºå›¾ç‰‡çš„åœºæ™¯ï¼‰
		node['iconPath'] = getIconPath(iconName)
		
		// ç”Ÿæˆæ˜¾ç¤ºåç§°: emoji + åç§°ï¼ˆè¡¨æ ¼æ–‡æœ¬åˆ—ä½¿ç”¨ï¼‰
		const name = node['name'] as string
		node['displayName'] = `${fallbackEmoji} ${name}`
		
		// ç”Ÿæˆèµ„æºè®¡æ•°æ ‡ç­¾: #(æ•°é‡)
		const resourceCount = node['resourceCount']
		if (resourceCount != null) {
			node['resourceLabel'] = `#(${resourceCount})`
		} else {
			node['resourceLabel'] = ''
		}
		
		// é€’å½’å¤„ç†å­èŠ‚ç‚¹
		const children = node['children']
		if (children != null && Array.isArray(children)) {
			const childList = children as UTSJSONObject[]
			for (let i = 0; i < childList.length; i++) {
				enrichNodeForDisplay(childList[i])
			}
		}
		
		return node
	}
	
	const loadGroup = async (groupId: string): Promise<GroupVM | null> => {
		// #ifdef WEB
		return await loadGroupWeb(groupId)
		// #endif
		// #ifndef WEB
		return await loadGroupSQL(groupId)
		// #endif
	}
	
	// #ifdef WEB
	const loadGroupWeb = async (groupId: string): Promise<GroupVM | null> => {
		try {
			const allGroups = await webGetAll('meta_tab_groups')
			const groups = allGroups.filter((g: any) => g.id == groupId)
			if (groups.length == 0) {
				console.log('Web: Group not found:', groupId)
				return null
			}
			
			const groupRow = groups[0]
			const groupVM: GroupVM = {
				id: groupRow.id as string,
				name: groupRow.name as string,
				tabs: []
			}
			
			// Load Tabs
			const allTabs = await webGetByIndex('meta_tabs', 'group_id', groupId)
			const tabs = allTabs.sort((a: any, b: any) => (a.sort_order || 0) - (b.sort_order || 0))
			console.log('Web: Found tabs:', tabs.length)
			
			for (let i = 0; i < tabs.length; i++) {
				const t = tabs[i] as any
				const tabId = t.id as string
				const tabVM: TabVM = {
					id: tabId,
					title: t.title as string,
					components: []
				}
				
				// Load Components
				const allComps = await webGetByIndex('meta_components', 'tab_id', tabId)
				const comps = allComps.sort((a: any, b: any) => (a.sort_order || 0) - (b.sort_order || 0))
				
				for (let j = 0; j < comps.length; j++) {
					const c = comps[j] as any
					const compId = c.id as string
					
					const compVM: ComponentVM = {
						id: compId,
						type: c.type as string,
						title: c.title as string,
						config: c.config,  // Object already parsed in IndexedDB
						data: []
					}
					
					// Load Data
					const records = await webGetByIndex('data_records', 'component_id', compId)
					compVM.data = records.map((r: any): UTSJSONObject => {
						return r.data as UTSJSONObject || {}
					})
					
					tabVM.components.push(compVM)
				}
				
				groupVM.tabs.push(tabVM)
			}
			
			console.log('Web: Group loaded:', groupVM.name, 'with', groupVM.tabs.length, 'tabs')
			return groupVM
		} catch (e) {
			console.error('Web loadGroup error:', e)
			return null
		}
	}
	// #endif
	
	// #ifndef WEB
	const loadGroupSQL = async (groupId: string): Promise<GroupVM | null> => {
		const groups = await querySQL("SELECT * FROM meta_tab_groups WHERE id = ?", [groupId])
		if (groups.length == 0) return null
		
		const groupRow = groups[0]
		const groupVM: GroupVM = {
			id: groupRow['id'] as string,
			name: groupRow['name'] as string,
			tabs: []
		}
		
		// Load Tabs
		const tabs = await querySQL("SELECT * FROM meta_tabs WHERE group_id = ? ORDER BY sort_order", [groupId])
		
		for (let i = 0; i < tabs.length; i++) {
			const t = tabs[i]
			const tabId = t['id'] as string
			const tabVM: TabVM = {
				id: tabId,
				title: t['title'] as string,
				components: []
			}
			
			// Load Components
			const comps = await querySQL("SELECT * FROM meta_components WHERE tab_id = ? ORDER BY sort_order", [tabId])
			for (let j = 0; j < comps.length; j++) {
				const c = comps[j]
				const compId = c['id'] as string
				
				// Parse config
				let config: any = null
				const configStr = c['config_json'] as string
				if (configStr != '') {
					try {
						config = JSON.parse(configStr)
					} catch (e) { console.error('Config parse error', e) }
				}
				
				const compVM: ComponentVM = {
					id: compId,
					type: c['type'] as string,
					title: c['title'] as string,
					config: config,
					data: []
				}
				
				// Load Data
				const records = await querySQL("SELECT data_json FROM data_records WHERE component_id = ?", [compId])
				compVM.data = records.map((r): UTSJSONObject => {
					const jsonStr = r['data_json'] as string
					try {
						return JSON.parse(jsonStr) as UTSJSONObject
					} catch (e) { return {} }
				})
				
				tabVM.components.push(compVM)
			}
			
			groupVM.tabs.push(tabVM)
		}
		
		return groupVM
	}
	// #endif

	
	const onTabChange = (groupId: string, tabId: any) => {
		activeTabs.set(groupId, tabId as string)
	}
	
	const getColumns = (comp: ComponentVM): UTSJSONObject[] => {
		if (Array.isArray(comp.config)) {
			return comp.config as UTSJSONObject[]
		}
		return []
	}
	
	const getCollapseConfig = (comp: ComponentVM): UTSJSONObject => {
		return comp.config as UTSJSONObject
	}
	
	// Helper to get string safely
	const getString = (obj: UTSJSONObject | null, key: string): string => {
		if (obj == null) return ''
		return obj[key]?.toString() ?? ''
	}
	
	const handleRowClick = async (row: UTSJSONObject) => {
		selectedRow.value = row
		// console.log('Row clicked:', row['id'], row['type'], row['name'])
		
		statusMessage.value = `é€‰ä¸­: ${row['name']} (${row['type']})`
		updateSelectedNodeInfo(row)
		
		// æ ¹æ®èŠ‚ç‚¹ç±»å‹åŠ¨æ€åŠ è½½å¯¹åº”çš„ Tab Group
		const nodeType = row['type'] as string
		const nodeId = row['id'] as string
		const nodeName = row['name'] as string
		
		let groupId = ''
		if (nodeType == 'process') groupId = 'group_process_view'
		else if (nodeType == 'procedure') groupId = 'group_procedure_view'
		else if (nodeType == 'step') groupId = 'group_step_view'
		
		if (groupId != '') {
			const group = await loadGroup(groupId)
			if (group != null) {
				// å°†å½“å‰èŠ‚ç‚¹æ•°æ®ç»‘å®šåˆ° Group çš„ç»„ä»¶ä¸­
				bindDataToGroup(group, row)
				topGroup.value = group
				
				// é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª Tab
				if (!activeTabs.has(group.id) && group.tabs.length > 0) {
					activeTabs.set(group.id, group.tabs[0].id)
				}
			}
		}
		
		// åŠ è½½åº•éƒ¨è¯¦æƒ…
		let bottomGroupId = ''
		if (nodeType == 'process') bottomGroupId = 'group_bottom_proc'
		else if (nodeType == 'procedure') bottomGroupId = 'group_bottom_op'
		else if (nodeType == 'step') bottomGroupId = 'group_bottom_step'
		
		if (bottomGroupId != '') {
			const group = await loadGroup(bottomGroupId)
			if (group != null) {
				bindDataToGroup(group, row)
				bottomGroup.value = group
			}
		}
		
		// åŠ è½½èŠ‚ç‚¹å…³è”çš„èµ„æºåˆ—è¡¨
		await loadNodeResources(nodeId, nodeName, nodeType)
	}
	
	// å°†èŠ‚ç‚¹æ•°æ®ç»‘å®šåˆ° Group ä¸­çš„å„ä¸ªç»„ä»¶
	const bindDataToGroup = (group: GroupVM, node: UTSJSONObject) => {
		for (let i = 0; i < group.tabs.length; i++) {
			const tab = group.tabs[i]
			for (let j = 0; j < tab.components.length; j++) {
				const comp = tab.components[j]
				const config = comp.config as UTSJSONObject
				const dataSource = config['dataSource'] as string
				
				// æ ¹æ® dataSource å¡«å…… comp.data
				comp.data = [] // Reset
				
				if (dataSource == 'self') {
					// è‡ªèº«æ•°æ®ï¼Œä½œä¸ºå•æ¡è®°å½•æ”¾å…¥æ•°ç»„
					comp.data.push(node)
				} else if (dataSource == 'children') {
					// å­èŠ‚ç‚¹åˆ—è¡¨
					const children = node['children']
					if (children != null && Array.isArray(children)) {
						const list = children as UTSJSONObject[]
						// ç¡®ä¿å­èŠ‚ç‚¹ä¹Ÿæœ‰æ˜¾ç¤ºç”¨å­—æ®µ
						comp.data = list.map((c: UTSJSONObject): UTSJSONObject => enrichNodeForDisplay(c))
					}
				} else if (dataSource == 'description') {
					// æè¿°æ–‡æœ¬ï¼ŒåŒ…è£…æˆå¯¹è±¡
					const desc = node['description']
					if (desc != null) {
						const item = { text: desc }
						comp.data.push(item)
					}
				} else if (dataSource == 'tools') {
					// å·¥å…·åˆ—è¡¨
					const tools = node['tools']
					if (tools != null && Array.isArray(tools)) {
						const list = tools as string[]
						comp.data = list.map((t: string): UTSJSONObject => {
							return { text: t }
						})
					}
				} else if (dataSource == 'materials') {
					// ç‰©æ–™åˆ—è¡¨
					const materials = node['materials']
					if (materials != null && Array.isArray(materials)) {
						const list = materials as string[]
						comp.data = list.map((m: string): UTSJSONObject => {
							return { text: m }
						})
					}
				}
			}
		}
	}
	
	// ä» config ä¸­æå– columns (ç”¨äºè¡¨æ ¼)
	const getColumnsFromConfig = (config: any): UTSJSONObject[] => {
		if (config == null) return []
		const confObj = config as UTSJSONObject
		// æ£€æŸ¥æ˜¯å¦æœ‰ columns å­—æ®µ (æ–°çš„ç»“æ„)
		if (confObj['columns'] != null) {
			const cols = confObj['columns']
			if (Array.isArray(cols)) return cols as UTSJSONObject[]
		}
		// å…¼å®¹æ—§ç»“æ„ (configæœ¬èº«å°±æ˜¯æ•°ç»„)
		if (Array.isArray(config)) return config as UTSJSONObject[]
		return []
	}
	
	// ä» config ä¸­æå– fields (ç”¨äº Key-Value)
	const getFieldsFromConfig = (config: any): UTSJSONObject[] => {
		if (config == null) return []
		const confObj = config as UTSJSONObject
		if (confObj['fields'] != null) {
			const fields = confObj['fields']
			if (Array.isArray(fields)) return fields as UTSJSONObject[]
		}
		return []
	}
	
	// è·å–èŠ‚ç‚¹ç±»å‹çš„ä¸­æ–‡æ ‡ç­¾
	const getNodeTypeLabel = (nodeType: string): string => {
		if (nodeType == 'process') return 'å·¥è‰º'
		if (nodeType == 'procedure') return 'å·¥åº'
		if (nodeType == 'step') return 'å·¥æ­¥'
		return nodeType
	}
	
	// æ›´æ–°é€‰ä¸­èŠ‚ç‚¹çš„è¯¦ç»†ä¿¡æ¯ (ä»…ç”¨äºæ—¥å¿—)
	const updateSelectedNodeInfo = (node: UTSJSONObject) => {
		/*
		const nodeType = node['type'] as string
		if (nodeType == 'process') {
			console.log('Selected process:', node['name'])
		} else if (nodeType == 'procedure') {
			console.log('Selected procedure:', node['name'])
		} else if (nodeType == 'step') {
			console.log('Selected step:', node['name'])
		}
		*/
	}
	
	// ============ èµ„æºç›¸å…³æ–¹æ³• ============
	
	/**
	 * åŠ è½½èŠ‚ç‚¹å…³è”çš„èµ„æºåˆ—è¡¨
	 * @param nodeId èŠ‚ç‚¹ID
	 * @param nodeName èŠ‚ç‚¹åç§°ï¼ˆç”¨äºæ˜¾ç¤ºæ ‡é¢˜ï¼‰
	 * @param nodeType èŠ‚ç‚¹ç±»å‹
	 */
	const loadNodeResources = async (nodeId: string, nodeName: string, nodeType: string) => {
		try {
			// æ›´æ–°æ ‡é¢˜
			const typeLabel = getNodeTypeLabel(nodeType)
			nodeResourcesTitle.value = `${typeLabel}èµ„æº - ${nodeName}`
			
			// ä»æ•°æ®åº“åŠ è½½èµ„æº
			const resources = await getResourcesByNodeId(nodeId)
			nodeResources.value = resources
			
			// æ¸…ç©ºé¢„è§ˆçŠ¶æ€
			previewResource.value = null
			
			// å¦‚æœæœ‰èµ„æºï¼Œé»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
			if (resources.length > 0) {
				previewResource.value = resources[0]
			}
			
			console.log(`Loaded ${resources.length} resources for node: ${nodeId}`)
		} catch (e) {
			console.error('loadNodeResources error:', e)
			nodeResources.value = []
			previewResource.value = null
		}
	}
	
	/**
	 * èµ„æºé€‰æ‹©äº‹ä»¶å¤„ç†
	 * @param item é€‰ä¸­çš„èµ„æºé¡¹
	 */
	const onResourceSelect = (item: ResourceItem) => {
		previewResource.value = item
		console.log('Resource selected:', item.name, item.type)
	}
	
	/**
	 * èµ„æºé¢„è§ˆé”™è¯¯å¤„ç†
	 * @param message é”™è¯¯æ¶ˆæ¯
	 */
	const onPreviewError = (message: string) => {
		uni.showToast({
			title: message,
			icon: 'none'
		})
	}
	
	/**
	 * åˆ‡æ¢èµ„æºåŒºåŸŸæœ€å¤§åŒ–
	 */
	const toggleResourceMaximize = () => {
		isResourceMaximized.value = !isResourceMaximized.value
		// é‡ç½®åˆ—è¡¨ä¸ºå¯è§çŠ¶æ€
		if (isResourceMaximized.value) {
			isFullscreenListVisible.value = true
		}
	}
	
	/**
	 * åˆ‡æ¢å…¨å±åˆ—è¡¨æ˜¾ç¤º/éšè—
	 */
	const toggleFullscreenList = () => {
		isFullscreenListVisible.value = !isFullscreenListVisible.value
	}
	
	/**
	 * åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªèµ„æº
	 */
	const goPrevResource = () => {
		if (nodeResources.value.length <= 1) return
		let idx = currentResourceIndex.value - 1
		if (idx < 0) idx = nodeResources.value.length - 1
		previewResource.value = nodeResources.value[idx]
		// åˆ‡æ¢èµ„æºæ—¶é‡ç½®å›¾ç‰‡å˜æ¢
		resetImageTransform()
	}
	
	/**
	 * åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªèµ„æº
	 */
	const goNextResource = () => {
		if (nodeResources.value.length <= 1) return
		let idx = currentResourceIndex.value + 1
		if (idx >= nodeResources.value.length) idx = 0
		previewResource.value = nodeResources.value[idx]
		// åˆ‡æ¢èµ„æºæ—¶é‡ç½®å›¾ç‰‡å˜æ¢
		resetImageTransform()
	}
	
	/**
	 * é‡ç½®å›¾ç‰‡å˜æ¢çŠ¶æ€
	 */
	const resetImageTransform = () => {
		imageScale.value = 1
		imageRotation.value = 0
	}
	
	/**
	 * å›¾ç‰‡æ”¾å¤§
	 */
	const imageZoomIn = () => {
		if (imageScale.value < 5) {
			imageScale.value = Math.min(5, imageScale.value + 0.25)
		}
	}
	
	/**
	 * å›¾ç‰‡ç¼©å°
	 */
	const imageZoomOut = () => {
		if (imageScale.value > 0.25) {
			imageScale.value = Math.max(0.25, imageScale.value - 0.25)
		}
	}
	
	/**
	 * å›¾ç‰‡å·¦æ—‹è½¬ 90 åº¦
	 */
	const imageRotateLeft = () => {
		imageRotation.value = (imageRotation.value - 90) % 360
	}
	
	/**
	 * å›¾ç‰‡å³æ—‹è½¬ 90 åº¦
	 */
	const imageRotateRight = () => {
		imageRotation.value = (imageRotation.value + 90) % 360
	}
	
	/**
	 * å›¾ç‰‡é‡ç½®åˆ°åŸå§‹çŠ¶æ€
	 */
	const imageReset = () => {
		resetImageTransform()
	}
	
	/**
	 * å…¨å±å›¾ç‰‡åŠ è½½å®Œæˆ
	 */
	const onFullscreenImageLoad = (e: UniImageLoadEvent) => {
		// å›¾ç‰‡åŠ è½½å®Œæˆæ—¶å¯ä»¥è¿›è¡Œå°ºå¯¸é€‚é…ç­‰æ“ä½œ
		const width = e.detail.width
		const height = e.detail.height
		
		if (width > 0 && height > 0) {
			const ratio = width / height
			// å¦‚æœæ˜¯ç«–å›¾ (é«˜å¤§äºå®½)ï¼Œåœ¨å®½å±/æ¨ªå±æ˜¾ç¤ºæ¨¡å¼ä¸‹ aspectFit ä¼šå¯¼è‡´æ˜¾ç¤ºè¿‡å°
			// è‡ªåŠ¨æ”¾å¤§ä»¥ä¾¿çœ‹å¾—æ›´æ¸…æ¥šï¼Œè®©å®½åº¦å°½å¯èƒ½æ’‘æ»¡
			// é˜ˆå€¼è®¾ä¸º 0.8 (å³ height > 1.25 * width)
			if (ratio < 0.8) {
				imageScale.value = 1.5
			}
		}
	}
	
	/**
	 * æ ¼å¼åŒ–æ—¶é•¿
	 */
	const formatDuration = (seconds: number): string => {
		const mins = Math.floor(seconds / 60)
		const secs = seconds % 60
		return `${mins}:${secs < 10 ? '0' : ''}${secs}`
	}
	
	/**
	 * è·å–èµ„æºç±»å‹æ ‡ç­¾
	 */
	const getTypeLabel = (type: string): string => {
		if (type == 'image') return 'å›¾ç‰‡'
		if (type == 'video') return 'è§†é¢‘'
		if (type == 'audio') return 'éŸ³é¢‘'
		if (type == 'document') return 'æ–‡æ¡£'
		return type
	}
	
</script>

<style>
	.header-container {
		height: 60px;
		background-color: #fff;
		border-bottom: 1px solid #e0e0e0;
		display: flex;
		flex-direction: row;
		align-items: center;
		padding: 0 20px;
		justify-content: space-between;
	}
	
	.header-logo {
		padding: 5px 10px;
		background-color: #f0f0f0;
		border-radius: 4px;
	}
	
	.header-actions {
		padding: 5px 10px;
	}
	
	.header-text {
		font-weight: bold;
		font-size: 14px;
	}

	.left-panel {
		flex: 1;
		display: flex;
		flex-direction: column;
		height: 100%;
		background-color: #fff;
		min-width: 0;
	}
	
	.main-content-top {
		padding: 20px;
		display: flex;
		flex-direction: column;
		flex: 1;
	}
	
	.main-content-bottom {
		padding: 20px;
		display: flex;
		flex-direction: column;
		background-color: #fafafa;
		height: 100px; /* Fixed height for bottom area demo */
	}

	.title {
		font-size: 24px;
		font-weight: bold;
		margin-bottom: 20px;
	}
	
	/* å³ä¾§é¢æ¿é¡¶éƒ¨åŒºåŸŸ - ç¡®ä¿å……æ»¡å®¹å™¨ */
	.right-panel-top {
		width: 100%;
		height: 100%;
		display: flex;
		flex-direction: column;
		background-color: #fff;
	}
	
	.right-header {
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		align-items: center;
		padding: 8px 10px;
		border-bottom: 1px solid #f0f0f0;
		width: 100%;
		box-sizing: border-box; /* ç¡®ä¿ padding ä¸ä¼šæ’‘å‡ºå®¹å™¨ */
	}
	
	.right-header-title {
		font-size: 14px;
		font-weight: 600;
		color: #333;
	}
	
	.right-header-btn {
		padding: 4px;
		border-radius: 4px;
		background-color: #f5f5f5;
		cursor: pointer;
	}
	
	.btn-icon {
		font-size: 14px;
		color: #555;
	}

	.right-panel {
		width: 100%;
		height: 100%;
		background-color: #fff;
		display: flex;
		flex-direction: column;
		padding: 10px;
		box-sizing: border-box;
	}

	.right-content {
		padding: 15px;
		display: flex;
		flex-direction: column;
	}
	
	.right-panel-bottom {
		padding: 6px;
		background-color: #f8f9fa;
		display: flex;
		flex-direction: column;
		height: 100px;
		border-top: 1px solid #e0e0e0;
	}
	
	.tab-content-wrap {
		padding: 10px 0;
	}
	
	.component-wrapper {
		margin-bottom: 20px;
		padding: 10px;
		border: 1px solid #eee;
		border-radius: 6rpx;
	}
	
	.comp-title {
		font-weight: bold;
		margin-bottom: 10px;
		font-size: 16px;
		display: block;
	}
	
	.kv-row {
		display: block;
		margin-bottom: 5px;
		font-size: 14px;
		color: #555;
	}
	
	.loading-state {
		display: flex;
		justify-content: center;
		padding: 20px;
		color: #999;
	}
	
	/* é€‰ä¸­èŠ‚ç‚¹è¯¦æƒ…æ ·å¼ */
	.selected-info {
		padding: 15px;
		display: flex;
		flex-direction: column;
	}
	
	.info-title {
		font-size: 18px;
		font-weight: bold;
		color: #333;
		margin-bottom: 10px;
	}
	
	.info-type {
		font-size: 14px;
		color: #666;
		margin-bottom: 5px;
	}
	
	.info-code {
		font-size: 14px;
		color: #888;
		margin-bottom: 10px;
	}
	
	.info-details {
		padding-top: 10px;
		border-top-width: 1px;
		border-top-style: solid;
		border-top-color: #eee;
	}
	
	.info-item {
		font-size: 14px;
		color: #555;
		margin-bottom: 5px;
	}
	
	.desc-label {
		color: #666;
		margin-top: 10px;
	}
	
	.info-desc {
		font-size: 14px;
		color: #333;
		line-height: 1.5;
	}
	
	.no-selection {
		display: flex;
		justify-content: center;
		align-items: center;
		height: 100%;
		color: #999;
		font-size: 14px;
	}
	
	/* ä¸­é—´åŒºåŸŸèŠ‚ç‚¹ä¿¡æ¯æ ·å¼ */
	.node-info-panel {
		padding: 15px;
		display: flex;
		flex-direction: column;
	}
	
	.info-row {
		font-size: 14px;
		color: #333;
		margin-bottom: 8px;
	}
	
	.info-label {
		font-size: 14px;
		color: #666;
		margin-top: 15px;
		margin-bottom: 5px;
	}
	
	/* åº•éƒ¨åŒºåŸŸæ ·å¼ */
	.bottom-header {
		padding-bottom: 5px;
		border-bottom: 1px solid #eee;
		margin-bottom: 5px;
	}
	
	.bottom-title {
		font-size: 16px;
		font-weight: bold;
		color: #333;
	}
	
	.component-wrapper-simple {
		padding: 5px 0;
	}
	
	.comp-title-small {
		font-size: 13px;
		color: #999;
		margin-bottom: 5px;
	}
	
	.info-grid {
		display: flex;
		flex-direction: row;
		flex-wrap: wrap;
	}
	
	.info-item-small {
		display: flex;
		flex-direction: row;
		margin-right: 20px;
		margin-bottom: 5px;
		align-items: center;
	}
	
	.info-label-small {
		font-size: 13px;
		color: #888;
		margin-right: 5px;
	}
	
	.info-val-small {
		font-size: 14px;
		color: #333;
		font-weight: 500;
	}
	
	.info-desc-small {
		font-size: 13px;
		color: #666;
		line-height: 1.4;
	}
	
	/* åˆ—è¡¨é¢æ¿æ ·å¼ */
	.list-panel {
		padding: 10px;
	}
	
	.list-item {
		display: flex;
		flex-direction: row;
		align-items: center;
		padding: 12px 15px;
		background-color: #fff;
		border-radius: 6px;
		margin-bottom: 8px;
		border: 1px solid #e8e8e8;
	}
	
	.list-item-code {
		font-size: 13px;
		color: #888;
		width: 120px;
	}
	
	.list-item-name {
		font-size: 14px;
		color: #333;
		flex: 1;
	}
	
	.list-item-duration {
		font-size: 13px;
		color: #666;
		width: 80px;
	}
	
	.list-item-simple {
		padding: 10px 15px;
		background-color: #f9f9f9;
		border-radius: 4px;
		margin-bottom: 6px;
	}
	
	.empty-hint {
		text-align: center;
		color: #999;
		font-size: 14px;
		padding: 20px;
	}
	
	/* Right Header */
	.right-header {
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		align-items: center;
		padding: 8px 12px;
		background-color: #f5f5f5;
		border-bottom: 1px solid #e0e0e0;
	}
	
	.right-header-title {
		font-size: 14px;
		color: #333;
		font-weight: 500;
	}
	
	.right-header-btn {
		width: 28px;
		height: 28px;
		display: flex;
		justify-content: center;
		align-items: center;
		background-color: rgba(0, 0, 0, 0.08);
		border-radius: 4px;
	}
	
	.btn-icon {
		font-size: 16px;
		color: #333;
	}
	
	/* Fullscreen Overlay */
	.resource-fullscreen-overlay {
		position: fixed;
		left: 0;
		top: 0;
		right: 0;
		bottom: 0;
		background-color: rgba(255, 255, 255, 0.98);
		z-index: 9999;
		display: flex;
		flex-direction: column;
	}
	
	.fullscreen-container {
		flex: 1;
		display: flex;
		flex-direction: column;
		padding: 0;
	}
	
	.fullscreen-header {
		display: flex;
		flex-direction: row;
		justify-content: space-between;
		align-items: center;
		padding: 12px 24px;
		background-color: #fff;
		border-bottom: 1px solid #e0e0e0;
	}
	
	.header-left {
		display: flex;
		flex-direction: row;
		align-items: center;
	}
	
	.fullscreen-title {
		font-size: 16px;
		color: #333;
		font-weight: 600;
	}
	
	.resource-counter {
		font-size: 14px;
		color: #888;
		margin-left: 12px;
	}
	
	.header-actions {
		display: flex;
		flex-direction: row;
		align-items: center;
	}
	
	.header-btn {
		width: 36px;
		height: 36px;
		display: flex;
		justify-content: center;
		align-items: center;
		background-color: rgba(0, 0, 0, 0.05);
		border-radius: 6px;
		margin-right: 12px;
	}
	
	.header-btn-icon {
		font-size: 18px;
		color: #333;
	}
	
	.fullscreen-close {
		width: 36px;
		height: 36px;
		display: flex;
		justify-content: center;
		align-items: center;
		background-color: rgba(0, 0, 0, 0.08);
		border-radius: 18px;
	}
	
	.close-icon {
		font-size: 18px;
		color: #333;
	}
	
	.fullscreen-content {
		flex: 1;
		display: flex;
		flex-direction: row;
		padding: 8px;
	}
	
	.fullscreen-preview {
		flex: 1;
		display: flex;
		flex-direction: row;
		position: relative;
		margin-right: 16px;
		background-color: #fff;
		border-radius: 8px;
		overflow: hidden;
		border: 1px solid #e0e0e0;
	}
	
	.fullscreen-preview.preview-full {
		margin-right: 0;
	}
	
	/* ä¸Š/ä¸‹ä¸€ä¸ªå¯¼èˆªæŒ‰é’® */
	.nav-btn {
		position: absolute;
		top: 50%;
		width: 40px;
		height: 80px;
		margin-top: -40px;
		display: flex;
		justify-content: center;
		align-items: center;
		background-color: rgba(0, 0, 0, 0.3);
		z-index: 10;
	}
	
	.nav-prev {
		left: 0;
		border-top-right-radius: 8px;
		border-bottom-right-radius: 8px;
	}
	
	.nav-next {
		right: 0;
		border-top-left-radius: 8px;
		border-bottom-left-radius: 8px;
	}
	
	.nav-icon {
		font-size: 32px;
		color: #fff;
		font-weight: bold;
	}
	
	/* å³ä¾§ç´§å‡‘ç¼©ç•¥å›¾åˆ—è¡¨ */
	.fullscreen-list {
		width: 140px;
		display: flex;
		flex-direction: column;
		background-color: #fff;
		border-radius: 8px;
		overflow: hidden;
		border: 1px solid #e0e0e0;
	}
	
	.fullscreen-list-inner {
		padding: 8px;
	}
	
	.fullscreen-thumb-item {
		display: flex;
		flex-direction: column;
		align-items: center;
		padding: 8px;
		margin-bottom: 8px;
		background-color: #f8f9fa;
		border-radius: 6px;
		border: 2px solid transparent;
	}
	
	.fullscreen-thumb-item.selected {
		border-color: #4a90e2;
		background-color: rgba(74, 144, 226, 0.1);
	}
	
	.thumb-wrapper {
		width: 100px;
		height: 70px;
		display: flex;
		justify-content: center;
		align-items: center;
		background-color: #e9ecef;
		border-radius: 4px;
		overflow: hidden;
	}
	
	.thumb-wrapper .thumb-img {
		width: 100%;
		height: 100%;
	}
	
	.thumb-wrapper .thumb-icon {
		font-size: 28px;
	}
	
	.thumb-name {
		font-size: 11px;
		color: #666;
		margin-top: 6px;
		text-align: center;
		overflow: hidden;
		text-overflow: ellipsis;
	}
	
	/* å›¾ç‰‡æŸ¥çœ‹å™¨ */
	.image-viewer-container {
		flex: 1;
		display: flex;
		flex-direction: column;
		overflow: hidden;
	}
	
	.image-scroll-view {
		flex: 1;
		background-color: #f0f0f0;
	}
	
	.image-transform-wrapper {
		display: flex;
		justify-content: center;
		align-items: center;
		min-width: 100%;
		min-height: 100%;
	}
	
	.fullscreen-image {
		max-width: 100%;
		max-height: 100%;
	}
	
	/* å›¾ç‰‡æ“ä½œå·¥å…·æ  */
	.image-toolbar {
		display: flex;
		flex-direction: row;
		justify-content: center;
		align-items: center;
		padding: 12px 20px;
		background-color: #fff;
		border-top: 1px solid #e0e0e0;
	}
	
	.toolbar-btn {
		display: flex;
		flex-direction: column;
		align-items: center;
		padding: 8px 16px;
		margin: 0 4px;
		background-color: #f5f5f5;
		border-radius: 6px;
	}
	
	.toolbar-icon {
		font-size: 20px;
		color: #333;
		font-weight: bold;
	}
	
	.toolbar-label {
		font-size: 10px;
		color: #666;
		margin-top: 2px;
	}
	
	.toolbar-info {
		display: flex;
		justify-content: center;
		align-items: center;
		padding: 8px 16px;
		margin: 0 8px;
		background-color: #e9ecef;
		border-radius: 6px;
		min-width: 60px;
	}
	
	.zoom-percentage {
		font-size: 14px;
		color: #333;
		font-weight: 600;
	}
	
	.toolbar-divider {
		width: 1px;
		height: 32px;
		background-color: #ddd;
		margin: 0 12px;
	}
</style>


