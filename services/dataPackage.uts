import { ComponentConfig, DataRecord, ImportProgress, ImportResult, ManifestFileRefs, PackageInfo, PackageManifest, TabConfig, TabGroup } from '@/types/data-package.uts'
import { ProcessInfo } from '@/types/process'
import { ResourceItem, inferResourceType } from '@/types/resource'
import { decryptPackage } from '@/utils/crypto'
import { beginTransaction, endTransaction, executeSQL, setTransactionSuccessful } from '@/services/database'
import { saveResource, extractResourcesFromNode, getAssetsBasePath } from '@/services/resourceService'
// #ifdef APP-ANDROID
import { ensureDirectory, writeFileBytes } from '@/services/resourceService'
// #endif
// #ifdef WEB
import { webPutData, webClearStore } from '@/services/database'
import { storeBlobAndGetUrl, clearBlobUrls } from '@/services/resourceService'
// #endif


/**
 * 导入状态回调类型
 */
export type ImportProgressCallback = (progress: ImportProgress) => void

/**
 * 当前选中的文件路径
 */
let selectedFilePath: string = ''

/**
 * 选择数据包文件
 * @returns Promise<PackageInfo> 数据包信息
 */
export function selectPackageFile(): Promise<PackageInfo> {
	return new Promise((resolve: (value: PackageInfo) => void, reject: (reason: Error) => void) => {
		// #ifdef APP-ANDROID
		selectFileAndroid(resolve, reject)
		// #endif
		
		// #ifdef APP-HARMONY
		selectFileHarmony(resolve, reject)
		// #endif
		
		// #ifdef WEB
		selectFileWeb(resolve, reject)
		// #endif
	})
}

// #ifdef APP-ANDROID
import Intent from 'android.content.Intent';
import Activity from 'android.app.Activity';
import Uri from 'android.net.Uri';

/**
 * Android 平台文件选择
 */
function selectFileAndroid(
	resolve: (value: PackageInfo) => void, 
	reject: (reason: Error) => void
): void {
	try {
		uni.chooseFile({
			count: 1,
			extension: ['.srd'],
			success: (res: UniChooseFileSuccessCallbackResult) => {
				if (res.tempFilePaths.length > 0) {
					const filePath = res.tempFilePaths[0]
					selectedFilePath = filePath
					
					// 获取文件信息
					uni.getFileInfo({
						filePath: filePath,
						success: (fileInfo: UniGetFileInfoSuccessCallbackResult) => {
							resolve({
								fileName: getFileName(filePath),
								fileSize: fileInfo.size,
								manifest: null,
								isValid: true,
								errorMessage: ''
							})
						},
						fail: (err: any) => {
							reject(new Error('获取文件信息失败'))
						}
					})
				} else {
					reject(new Error('未选择文件'))
				}
			},
			fail: (err: any) => {
				reject(new Error('选择文件失败'))
			}
		})
	} catch (e: Error) {
		reject(e)
	}
}
// #endif

// #ifdef APP-HARMONY
/**
 * HarmonyOS 平台文件选择
 */
function selectFileHarmony(
	resolve: (value: PackageInfo) => void, 
	reject: (reason: Error) => void
): void {
	try {
		uni.chooseFile({
			count: 1,
			extension: ['.srd'],
			success: (res: UniChooseFileSuccessCallbackResult) => {
				if (res.tempFilePaths.length > 0) {
					const filePath = res.tempFilePaths[0]
					selectedFilePath = filePath
					
					uni.getFileInfo({
						filePath: filePath,
						success: (fileInfo: UniGetFileInfoSuccessCallbackResult) => {
							resolve({
								fileName: getFileName(filePath),
								fileSize: fileInfo.size,
								manifest: null,
								isValid: true,
								errorMessage: ''
							})
						},
						fail: (err: any) => {
							reject(new Error('获取文件信息失败'))
						}
					})
				} else {
					reject(new Error('未选择文件'))
				}
			},
			fail: (err: any) => {
				reject(new Error('选择文件失败'))
			}
		})
	} catch (e: Error) {
		reject(e)
	}
}
// #endif

// #ifdef WEB
/**
 * Web 平台文件选择
 */
function selectFileWeb(
	resolve: (value: PackageInfo) => void, 
	reject: (reason: Error) => void
): void {
	try {
		const input = document.createElement('input')
		input.type = 'file'
		input.accept = '.srd'
		
		input.onchange = (event: Event) => {
			const target = event.target as HTMLInputElement
			if (target.files != null && target.files.length > 0) {
				const file = target.files[0]
				selectedFilePath = URL.createObjectURL(file)
				
				resolve({
					fileName: file.name,
					fileSize: file.size,
					manifest: null,
					isValid: true,
					errorMessage: ''
				})
			} else {
				reject(new Error('未选择文件'))
			}
		}
		
		input.click()
	} catch (e: any) {
		reject(e)
	}
}
// #endif

/**
 * 获取文件名
 */
function getFileName(filePath: string): string {
	const parts = filePath.split('/')
	return parts[parts.length - 1]
}

/**
 * 验证并预览数据包
 * @param filePath - 文件路径
 * @returns Promise<PackageManifest> 数据包清单
 */
export function validatePackage(filePath: string = selectedFilePath): Promise<PackageManifest> {
	const actualPath = filePath != '' ? filePath : selectedFilePath
	console.log('validatePackage using path:', actualPath)
	return new Promise((resolve: (value: PackageManifest) => void, reject: (reason: Error) => void) => {
		if (actualPath == '') {
			reject(new Error('未选择数据包文件'))
			return
		}
		readFileAsArrayBuffer(actualPath)
			.then((encryptedData: ArrayBuffer) => {
				// 尝试解密，如果失败则假设为未加密的ZIP
				let zipData = encryptedData
				const decryptResult = decryptPackage(encryptedData)
				if (decryptResult.success && decryptResult.data != null) {
					zipData = decryptResult.data!
				}
				
				// 解压并读取清单文件
				parseManifestFromZip(zipData)
					.then((manifest: PackageManifest) => {
						// 自动填充工艺数量
						if (manifest.processCount == null) {
							if (manifest.files != null && manifest.files?.processes != null) {
								manifest.processCount = manifest.files?.processes?.length
							} else if (manifest.processFiles != null) {
								manifest.processCount = manifest.processFiles?.length
							} else {
								manifest.processCount = 0
							}
						}
						resolve(manifest)
					})
					.catch((e: any) => {
						reject(new Error(e.toString()))
					})
			})
			.catch((e: any) => {
				reject(new Error(e.toString()))
			})
	})
}

/**
 * 导入数据包
 * @param filePath - 文件路径
 * @param onProgress - 进度回调
 * @returns Promise<ImportResult> 导入结果
 */
export function importPackage(
	filePath: string = selectedFilePath, 
	onProgress: ImportProgressCallback | null = null
): Promise<ImportResult> {
	const startTime = Date.now()
	const actualPath = filePath != '' ? filePath : selectedFilePath
	console.log('importPackage using path:', actualPath)
	
	return new Promise((resolve: (value: ImportResult) => void, reject: (reason: Error) => void) => {
		if (actualPath == '') {
			reject(new Error('未选择数据包文件'))
			return
		}
		
		// 更新进度：开始读取文件
		if (onProgress != null) {
			onProgress({
				current: 0,
				total: 100,
				currentFile: '读取数据包...',
				status: 'reading'
			})
		}
		
		readFileAsArrayBuffer(actualPath)

			.then((encryptedData: ArrayBuffer) => {
				// 更新进度：解密中
				if (onProgress != null) {
					onProgress({
						current: 20,
						total: 100,
						currentFile: '解密数据包...',
						status: 'decrypting'
					})
				}
				
				let zipData = encryptedData
				const decryptResult = decryptPackage(encryptedData)
				if (decryptResult.success && decryptResult.data != null) {
					zipData = decryptResult.data!
				}
				
				// 尝试作为普通 JSON 解析 (单文件数据包)
				
				// 更新进度：解压中
				if (onProgress != null) {
					onProgress({
						current: 40,
						total: 100,
						currentFile: '解压数据包...',
						status: 'extracting'
					})
				}
				
				// 解压并解析数据
				extractAndParsePackage(zipData, onProgress)
					.then((res: ImportResult) => {
						// 更新进度：完成
						if (onProgress != null) {
							onProgress({
								current: 100,
								total: 100,
								currentFile: '导入完成',
								status: 'completed'
							})
						}
						
						res.importTime = Date.now() - startTime
						resolve(res)
					})
					.catch((e: any) => {
						reject(new Error(JSON.stringify(e)))
					})
			})
			.catch((e: any) => {
				reject(new Error(JSON.stringify(e)))
			})
	})
}

/**
 * 读取文件为 ArrayBuffer
 */
function readFileAsArrayBuffer(filePath: string): Promise<ArrayBuffer> {
	return new Promise((resolve: (value: ArrayBuffer) => void, reject: (reason: Error) => void) => {
		// #ifdef APP-ANDROID || APP-HARMONY
		uni.getFileSystemManager().readFile({
			filePath: filePath,
			success: (res: ReadFileSuccessCallbackResult) => {
				resolve(res.data as ArrayBuffer)
			},
			fail: (err: any) => {
				reject(new Error('读取文件失败'))
			}
		})
		// #endif
		
		// #ifdef WEB
		// @ts-ignore
		fetch(filePath)
			.then((response: Response) => response.arrayBuffer())
			.then((buffer: ArrayBuffer) => {
				resolve(buffer)
			})
			.catch((e: any) => {
				reject(new Error(e.toString()))
			})
		// #endif
	})
}

/**
 * 从 ZIP 数据中解析清单文件
 */
function parseManifestFromZip(zipData: ArrayBuffer): Promise<PackageManifest> {
	return new Promise((resolve: (value: PackageManifest) => void, reject: (reason: Error) => void) => {
		// #ifdef APP-ANDROID
		parseManifestAndroid(zipData, resolve, reject)
		// #endif
		
		// #ifdef APP-HARMONY
		parseManifestHarmony(zipData, resolve, reject)
		// #endif
		
		// #ifdef WEB
		parseManifestWeb(zipData, resolve, reject)
		// #endif
	})
}

// #ifdef APP-ANDROID
import ZipInputStream from 'java.util.zip.ZipInputStream';
import ByteArrayInputStream from 'java.io.ByteArrayInputStream';
import ByteArrayOutputStream from 'java.io.ByteArrayOutputStream';

function parseManifestAndroid(
	zipData: ArrayBuffer,
	resolve: (value: PackageManifest) => void,
	reject: (reason: Error) => void
): void {
	try {
		const inputStream = new ByteArrayInputStream(new Int8Array(zipData) as ByteArray)
		const zipStream = new ZipInputStream(inputStream)
		
		let entry = zipStream.getNextEntry()
		while (entry != null) {
			if (entry.getName() == 'manifest.json') {
				const outputStream = new ByteArrayOutputStream()
				const buffer = new ByteArray(1024)
				let len = zipStream.read(buffer)
				while (len > 0) {
					outputStream.write(buffer, 0, len)
					len = zipStream.read(buffer)
				}
				
				const manifestJson = outputStream.toString('UTF-8')
				const manifest = JSON.parse(manifestJson) as PackageManifest
				
				zipStream.close()
				resolve(manifest)
				return
			}
			entry = zipStream.getNextEntry()
		}
		
		zipStream.close()
		reject(new Error('数据包中未找到清单文件'))
	} catch (e: any) {
		reject(new Error('解析清单文件失败：' + e.toString()))
	}
}
// #endif

// #ifdef APP-HARMONY
function parseManifestHarmony(
	zipData: ArrayBuffer,
	resolve: (value: PackageManifest) => void,
	reject: (reason: Error) => void
): void {
	// HarmonyOS 实现
	reject(new Error('HarmonyOS ZIP 解析待实现'))
}
// #endif

// #ifdef WEB
import JSZip from 'jszip'

function parseManifestWeb(
	zipData: ArrayBuffer,
	resolve: (value: PackageManifest) => void,
	reject: (reason: Error) => void
): void {
	console.log('Web: Loading ZIP for manifest parsing, size:', zipData.byteLength);
	JSZip.loadAsync(zipData).then((zip: JSZip) => {
		console.log('Web: ZIP loaded successfully. Files:', Object.keys(zip.files));
		const manifestFile = zip.file("manifest.json")
		if (manifestFile != null) {
			manifestFile.async("string").then((content: string) => {
				console.log('Web: manifest.json read, length:', content.length);
				try {
					const manifest = JSON.parse(content) as PackageManifest
					console.log('Web: Manifest parsed successfully:', manifest.version);
					resolve(manifest)
				} catch (e: any) {
					console.error('Web: Manifest JSON parse error:', e);
					reject(new Error("清单文件解析失败: " + e.message))
				}
			}).catch((e: any) => {
				console.error('Web: Manifest file read error:', e);
				reject(new Error("读取清单文件失败: " + e.message))
			})
		} else {
			console.error('Web: manifest.json not found in ZIP');
			reject(new Error("数据包中未找到 manifest.json"))
		}
	}).catch((e: any) => {
		console.error('Web: ZIP load failed:', e);
		reject(new Error("ZIP 加载失败: " + e.message))
	})
}
// #endif

/**
 * 解压并解析数据包内容
 */
function extractAndParsePackage(
	zipData: ArrayBuffer, 
	onProgress: ImportProgressCallback | null
): Promise<ImportResult> {
	return new Promise((resolve: (value: ImportResult) => void, reject: (reason: Error) => void) => {
		// #ifdef APP-ANDROID
		extractAndParseAndroid(zipData, onProgress, resolve, reject)
		// #endif
		
		// #ifdef APP-HARMONY
		extractAndParseHarmony(zipData, onProgress, resolve, reject)
		// #endif
		
		// #ifdef WEB
		extractAndParseWeb(zipData, onProgress, resolve, reject)
		// #endif
	})
}

// #ifdef APP-ANDROID
function extractAndParseAndroid(
	zipData: ArrayBuffer,
	onProgress: ImportProgressCallback | null,
	resolve: (value: ImportResult) => void,
	reject: (reason: Error) => void
): void {
	try {
		const inputStream = new ByteArrayInputStream(new Int8Array(zipData) as ByteArray)
		const zipStream = new ZipInputStream(inputStream)
		
		const processes: ProcessInfo[] = []
		let manifest: PackageManifest | null = null
		
		// 存储所有 JSON 文件内容，用于 V2 分离文件格式
		const jsonFiles = new Map<string, string>()
		
		// V3: 资源文件保存路径映射（原始路径 -> 本地路径）
		const savedAssetPaths = new Map<string, string>()
		const assetsBasePath = getAssetsBasePath()
		
		// 确保资源目录存在
		ensureDirectory(assetsBasePath)
		
		let entry = zipStream.getNextEntry()
		
		while (entry != null) {
			const entryName = entry.getName()
			
			// 读取 json 文件到内存
			if (entryName.endsWith('.json')) {
				const outputStream = new ByteArrayOutputStream()
				const buffer = new ByteArray(1024)
				let len = zipStream.read(buffer)
				while (len > 0) {
					outputStream.write(buffer, 0, len)
					len = zipStream.read(buffer)
				}
				const content = outputStream.toString('UTF-8')
				jsonFiles.set(entryName, content)
			}
			// V3: 保存资源文件到沙盒
			else if (isAssetFile(entryName)) {
				try {
					// 读取文件内容
					const outputStream = new ByteArrayOutputStream()
					const buffer = new ByteArray(4096)
					let len = zipStream.read(buffer)
					while (len > 0) {
						outputStream.write(buffer, 0, len)
						len = zipStream.read(buffer)
					}
					const fileBytes = outputStream.toByteArray()
					
					// 确定本地保存路径
					const localPath = assetsBasePath + '/' + getRelativeAssetPath(entryName)
					
					// 写入文件
					if (writeFileBytes(localPath, fileBytes)) {
						savedAssetPaths.set(entryName, localPath)
						console.log('Android: Saved asset:', entryName, '->', localPath)
					} else {
						console.warn('Android: Failed to save asset:', entryName)
					}
				} catch (e) {
					console.error('Android: Error saving asset:', entryName, e)
				}
			}
			
			entry = zipStream.getNextEntry()
		}
		
		zipStream.close()
		
		// 解析 manifest
		const manifestContent = jsonFiles.get('manifest.json')
		if (manifestContent != null) {
			manifest = JSON.parse(manifestContent) as PackageManifest
		}
		
		if (manifest == null) {
			reject(new Error('数据包中未找到 manifest.json'))
			return
		}
		
		// 检测是 V2 (分离文件) 还是 V1 (内联) 格式
		const isV2 = manifest.files != null
		
		// 解析 UI 配置
		let groups: TabGroup[] = []
		let tabs: TabConfig[] = []
		let components: ComponentConfig[] = []
		let records: DataRecord[] = []
		
		if (isV2 && manifest.files != null) {
			// V2: 从分离文件中读取
			const files = manifest.files
			
			if (files.groups != null) {
				const content = jsonFiles.get(files.groups)
				if (content != null) {
					groups = JSON.parse(content) as TabGroup[]
				}
			}
			
			if (files.tabs != null) {
				const content = jsonFiles.get(files.tabs)
				if (content != null) {
					tabs = JSON.parse(content) as TabConfig[]
				}
			}
			
			if (files.components != null) {
				const content = jsonFiles.get(files.components)
				if (content != null) {
					components = JSON.parse(content) as ComponentConfig[]
				}
			}
			
			if (files.records != null) {
				const content = jsonFiles.get(files.records)
				if (content != null) {
					records = JSON.parse(content) as DataRecord[]
				}
			}
			
			// 解析工艺文件
			if (files.processes != null) {
				for (const processPath of files.processes) {
					const content = jsonFiles.get(processPath)
					if (content != null) {
						const processInfo = JSON.parse(content) as ProcessInfo
						processes.push(processInfo)
					}
				}
			}
		} else {
			// V1: 从 manifest 内联数据读取
			groups = manifest.groups ?? []
			tabs = manifest.tabs ?? []
			components = manifest.components ?? []
			records = manifest.records ?? []
			
			// V1: 解析 processes 目录下的文件
			for (const [fileName, content] of jsonFiles) {
				if (fileName.startsWith('processes/')) {
					const processInfo = JSON.parse(content) as ProcessInfo
					processes.push(processInfo)
				}
			}
		}
		
		// 构建临时 manifest 用于保存 (兼容现有 saveUiConfigurationToDatabase)
		const fullManifest: PackageManifest = {
			version: manifest.version,
			groups: groups,
			tabs: tabs,
			components: components,
			records: records
		}
		
		// 开始事务
		beginTransaction()
		
		try {
			// 保存 UI 配置
			let uiConfigCount = saveUiConfigurationToDatabase(fullManifest)
			
		// V3: 从工艺数据中提取资源元数据
			let resourceCount = 0
			const allResources: ResourceItem[] = []
			
			for (const process of processes) {
				const processObj = process as UTSJSONObject
				const extractedResources = extractResourcesFromNode(processObj)
				
				for (const res of extractedResources) {
					// 使用保存的路径映射来更新资源的本地路径
					const originalPath = res.originalPath
					const localPath = savedAssetPaths.get(originalPath)
					
					if (localPath != null) {
						res.path = localPath
					} else {
						// 尝试使用替换斜杠的路径查找
						const altPath = originalPath.replace(/\//g, '\\')
						const altLocalPath = savedAssetPaths.get(altPath)
						if (altLocalPath != null) {
							res.path = altLocalPath
						} else {
							// 如果找不到已保存的文件，跳过该资源
							console.warn('Android: Resource file not saved:', originalPath)
							continue
						}
					}
					
					// 处理缩略图路径
					if (res.thumbnail != '') {
						const thumbPath = savedAssetPaths.get(res.thumbnail)
						if (thumbPath != null) {
							res.thumbnail = thumbPath
						} else {
							res.thumbnail = ''  // 缩略图未保存，清空
						}
					}
					
					allResources.push(res)
				}
			}
			
			// 保存工艺数据
			saveProcessesToDatabase(processes)
				.then(async () => {
					// 保存资源元数据
					try {
						for (const res of allResources) {
							await saveResource(res)
							resourceCount++
						}
						console.log('Android: Saved resources:', resourceCount)
					} catch (e) {
						console.error('Android: Save resources failed:', e)
					}
					
					setTransactionSuccessful()
					resolve({
						success: true,
						message: '导入成功',
						processCount: processes.length,
						uiConfigCount: uiConfigCount,
						resourceCount: resourceCount,
						importTime: 0
					})
				})
				.catch((e: any) => {
					throw e
				})
				.finally(() => {
					endTransaction()
				})
				
		} catch (e: any) {
			endTransaction()
			reject(new Error('数据库保存失败: ' + e.toString()))
		}
			
	} catch (e: any) {
		reject(new Error('解析数据包失败：' + e.toString()))
	}
}

/**
 * 判断是否为资源文件
 * @param entryName ZIP 条目名称
 */
function isAssetFile(entryName: string): boolean {
	const normalized = entryName.toLowerCase().replace(/\\/g, '/')
	
	// 检查是否在 assets 目录下
	if (!normalized.startsWith('assets/')) {
		return false
	}
	
	// 排除 icons 目录（图标使用项目静态资源）
	if (normalized.includes('/icons/')) {
		return false
	}
	
	// 检查扩展名
	const imageExts = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg']
	const videoExts = ['.mp4', '.webm', '.avi', '.mov', '.mkv']
	const audioExts = ['.mp3', '.wav', '.aac', '.ogg', '.m4a']
	const docExts = ['.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.txt']
	
	const allExts = imageExts.concat(videoExts).concat(audioExts).concat(docExts)
	
	for (const ext of allExts) {
		if (normalized.endsWith(ext)) {
			return true
		}
	}
	
	return false
}

/**
 * 获取相对资源路径（去除 assets/ 前缀）
 * @param entryName ZIP 条目名称
 */
function getRelativeAssetPath(entryName: string): string {
	const normalized = entryName.replace(/\\/g, '/')
	
	// 移除 assets/ 前缀
	if (normalized.startsWith('assets/')) {
		return normalized.substring(7)
	}
	
	return normalized
}
// #endif

// #ifdef APP-HARMONY
function extractAndParseHarmony(
	zipData: ArrayBuffer,
	onProgress: ImportProgressCallback | null,
	resolve: (value: ImportResult) => void,
	reject: (reason: Error) => void
): void {
	reject(new Error('HarmonyOS 解析待实现'))
}
// #endif

// #ifdef WEB
function extractAndParseWeb(
	zipData: ArrayBuffer,
	onProgress: ImportProgressCallback | null,
	resolve: (value: ImportResult) => void,
	reject: (reason: Error) => void
): void {
	console.log('Web: Starting extraction, size:', zipData.byteLength);
	JSZip.loadAsync(zipData).then(async (zip: JSZip) => {
		try {
			// 1. 解析 manifest
			let manifest: PackageManifest | null = null
			const manifestFile = zip.file("manifest.json")
			if (manifestFile != null) {
				console.log('Web: manifest.json found');
				const content = await manifestFile.async("string")
				manifest = JSON.parse(content) as PackageManifest
				console.log('Web: Manifest version:', manifest.version);
			} else {
				console.warn('Web: manifest.json NOT found');
				reject(new Error("数据包中未找到 manifest.json"))
				return
			}
			
			// 2. 检测是 V2 (分离文件) 还是 V1 (内联) 格式
			const isV2 = manifest.files != null
			console.log('Web: Package format:', isV2 ? 'V2 (separated)' : 'V1 (inline)');
			
			// 3. 读取 UI 配置
			let groups: TabGroup[] = []
			let tabs: TabConfig[] = []
			let components: ComponentConfig[] = []
			let records: DataRecord[] = []
			let iconConfig: UTSJSONObject | null = null
			
			if (isV2 && manifest.files != null) {
				// V2: 从分离文件中读取
				const files = manifest.files
				
				// 辅助函数：从 ZIP 中查找文件（兼容正斜杠和反斜杠）
				const findZipFile = (path: string): any => {
					// 先尝试原路径
					let file = zip.file(path)
					if (file != null) return file
					// 尝试替换斜杠
					const altPath = path.replace(/\//g, '\\')
					file = zip.file(altPath)
					if (file != null) return file
					// 尝试另一种替换
					const altPath2 = path.replace(/\\/g, '/')
					return zip.file(altPath2)
				}
				
				if (files.groups != null) {
					const groupsFile = findZipFile(files.groups)
					if (groupsFile != null) {
						const content = await groupsFile.async("string")
						groups = JSON.parse(content) as TabGroup[]
						console.log('Web: Loaded groups:', groups.length);
					} else {
						console.warn('Web: groups file not found:', files.groups)
					}
				}
				
				if (files.tabs != null) {
					const tabsFile = findZipFile(files.tabs)
					if (tabsFile != null) {
						const content = await tabsFile.async("string")
						tabs = JSON.parse(content) as TabConfig[]
						console.log('Web: Loaded tabs:', tabs.length);
					} else {
						console.warn('Web: tabs file not found:', files.tabs)
					}
				}
				
				if (files.components != null) {
					const componentsFile = findZipFile(files.components)
					if (componentsFile != null) {
						const content = await componentsFile.async("string")
						components = JSON.parse(content) as ComponentConfig[]
						console.log('Web: Loaded components:', components.length);
					} else {
						console.warn('Web: components file not found:', files.components)
					}
				}
				
				if (files.records != null) {
					const recordsFile = findZipFile(files.records)
					if (recordsFile != null) {
						const content = await recordsFile.async("string")
						records = JSON.parse(content) as DataRecord[]
						console.log('Web: Loaded records:', records.length);
					} else {
						console.warn('Web: records file not found:', files.records)
					}
				}
				
				// 加载图标配置（图标文件在 static/icons/ 目录，数据包只存配置）
				if (files.icons != null) {
					const iconsFile = findZipFile(files.icons)
					if (iconsFile != null) {
						const content = await iconsFile.async("string")
						iconConfig = JSON.parse(content) as UTSJSONObject
						console.log('Web: Loaded icons config');
					}
				}
			} else {
				// V1: 从 manifest 内联数据读取
				groups = manifest.groups ?? []
				tabs = manifest.tabs ?? []
				components = manifest.components ?? []
				records = manifest.records ?? []
			}
			
			// 4. 解析 processes - 支持 V1 和 V2 两种路径来源
			const processes: ProcessInfo[] = []
			let processFilePaths: string[] = []
			
			if (isV2 && manifest.files != null && manifest.files.processes != null) {
				processFilePaths = manifest.files.processes
			} else if (manifest.processFiles != null) {
				processFilePaths = manifest.processFiles
			} else {
				// 兼容：遍历 ZIP 查找 processes 目录
				const allFiles = Object.keys(zip.files)
				processFilePaths = allFiles.filter((name) => {
					const normalized = name.replace(/\\/g, '/')
					return normalized.startsWith('processes/') && normalized.endsWith('.json')
				})
			}
			
			console.log('Web: Process files to load:', processFilePaths.length, processFilePaths);
			console.log('Web: All ZIP files:', Object.keys(zip.files));
			
			// 辅助函数：从 ZIP 中查找文件（兼容正斜杠和反斜杠） - 如在 isV2 块外需要，重新定义
			const findProcessFile = (path: string): any => {
				let file = zip.file(path)
				if (file != null) return file
				const altPath = path.replace(/\//g, '\\')
				file = zip.file(altPath)
				if (file != null) return file
				const altPath2 = path.replace(/\\/g, '/')
				return zip.file(altPath2)
			}
			
			for (const filePath of processFilePaths) {
				console.log('Web: Trying to load process file:', filePath);
				const file = findProcessFile(filePath)
				if (file != null && !file.dir) {
					const content = await file.async("string")
					try {
						const process = JSON.parse(content) as ProcessInfo
						processes.push(process)
						console.log('Web: Parsed process:', process.id);
					} catch(e) {
						console.error('Web: Failed to parse process file:', filePath, e);
					}
				} else {
					console.warn('Web: Process file not found in ZIP:', filePath);
				}
			}
			
			// 5. 保存到数据库 (Web 使用 IndexedDB)
			console.log('Web: Saving to database via IndexedDB...');
			
			try {
				// 先清空旧数据
				console.log('Web: Clearing old data...');
				await webClearStore('meta_tab_groups')
				await webClearStore('meta_tabs')
				await webClearStore('meta_components')
				await webClearStore('data_records')
				await webClearStore('t_process')
				await webClearStore('t_icon_config')
				console.log('Web: Old data cleared');
				
				let uiConfigCount = 0
				
				// 保存 UI 分组
				for (const g of groups) {
					await webPutData('meta_tab_groups', g)
					uiConfigCount++
				}
				
				// 保存 Tabs
				for (const t of tabs) {
					await webPutData('meta_tabs', t)
					uiConfigCount++
				}
				
				// 保存组件
				for (const c of components) {
					await webPutData('meta_components', c)
					uiConfigCount++
				}
				
				// 保存数据记录
				for (const r of records) {
					await webPutData('data_records', r)
					uiConfigCount++
				}
				
				// 保存图标配置（只存配置，图标文件在 static/icons/）
				if (iconConfig != null) {
					const nodeIcons = iconConfig['nodeIcons'] as UTSJSONObject
					if (nodeIcons != null) {
						for (const nodeType of Object.keys(nodeIcons)) {
							const cfg = nodeIcons[nodeType] as UTSJSONObject
							await webPutData('t_icon_config', {
								node_type: nodeType,
								icon_name: cfg['icon'] ?? nodeType,
								fallback: cfg['fallback'] ?? ''
							})
						}
					}
					console.log('Web: Saved icon config');
				}
				
				// 保存工艺数据
				for (const p of processes) {
					await webPutData('t_process', p)
				}
				
				// V3: 提取并保存资源
				let resourceCount = 0
				
				// 判断是否有 assets 目录配置
				const hasAssets = isV2 && manifest.files != null && manifest.files.assets != null
				const assetsPrefix = hasAssets ? (manifest.files!.assets ?? 'assets/') : 'assets/'
				
				// 清空旧的资源记录
				await webClearStore('t_resources')
				clearBlobUrls()
				
				// 从工艺数据中提取资源引用并处理
				for (const process of processes) {
					const processObj = process as UTSJSONObject
					const extractedResources = extractResourcesFromNode(processObj)
					
					for (const res of extractedResources) {
						// 在 ZIP 中查找资源文件
						const resourcePath = res.originalPath
						if (resourcePath == '') continue
						
						const resourceFile = findProcessFile(resourcePath)
						if (resourceFile != null && !resourceFile.dir) {
							try {
								// 读取资源为 Blob
								const blob = await resourceFile.async("blob")
								
								// 创建 Blob URL 作为本地路径 (当前会话有效)
								const blobUrl = storeBlobAndGetUrl(res.id, blob)
								res.path = blobUrl
								
								let thumbBlobData: Blob | null = null
								
								// 处理缩略图
								if (res.thumbnail != '') {
									const thumbFile = findProcessFile(res.thumbnail)
									if (thumbFile != null) {
										const thumbBlob = await thumbFile.async("blob")
										const thumbUrl = storeBlobAndGetUrl(res.id + '_thumb', thumbBlob)
										res.thumbnail = thumbUrl
										thumbBlobData = thumbBlob
									}
								}
								
								// 保存资源元数据到数据库
								// Web环境：同时保存 Blob 数据以实现持久化
								await webPutData('t_resources', {
									id: res.id,
									node_id: res.nodeId,
									type: res.type,
									name: res.name,
									path: res.path,
									original_path: res.originalPath,
									thumbnail: res.thumbnail,
									duration: res.duration,
									size: res.size,
									description: res.description,
									sort_order: res.sortOrder,
									// 存储 Blob 数据，确保刷新后可用
									blob_data: blob,
									thumbnail_blob: thumbBlobData
								})
								
								resourceCount++
								console.log('Web: Extracted resource:', res.name);
							} catch (e) {
								console.warn('Web: Failed to extract resource:', resourcePath, e);
							}
						} else {
							console.warn('Web: Resource file not found in ZIP:', resourcePath);
						}
					}
				}
				
				console.log('Web: DB Save success, UI configs:', uiConfigCount, ', Processes:', processes.length, ', Resources:', resourceCount);
				
				resolve({
					success: true,
					message: '导入成功',
					processCount: processes.length,
					uiConfigCount: uiConfigCount,
					resourceCount: resourceCount,
					importTime: 0
				})
			} catch (e: any) {
				console.error('Web: DB Save failed', e);
				reject(new Error('数据库保存失败: ' + e.message))
			}
			
		} catch (e: any) {
			console.error('Web: Extraction error', e);
			reject(new Error("Web 导入处理失败: " + e.message))
		}
	}).catch((e: any) => {
		console.error('Web: ZIP load failed in extraction', e);
		reject(new Error("ZIP 加载失败: " + e.message))
	})
}
// #endif


/**
 * 保存 UI 配置到数据库
 */
function saveUiConfigurationToDatabase(manifest: PackageManifest): number {
	let count = 0
	
	// 导入分组
	const groups = manifest.groups
	if (groups != null) {
		for (let i = 0; i < groups.length; i++) {
			const g = groups[i]
			executeSQL(
				"INSERT OR REPLACE INTO meta_tab_groups (id, name, description, sort_order) VALUES (?, ?, ?, ?)",
				[g.id, g.name, g.description, g.sort_order]
			)
			count++
		}
	}
	
	// 导入 Tab
	const tabs = manifest.tabs
	if (tabs != null) {
		for (let i = 0; i < tabs.length; i++) {
			const t = tabs[i]
			executeSQL(
				"INSERT OR REPLACE INTO meta_tabs (id, group_id, title, sort_order, visible_condition) VALUES (?, ?, ?, ?, ?)",
				[t.id, t.group_id, t.title, t.sort_order, t.visible_condition]
			)
			count++
		}
	}
	
	// 导入组件
	const components = manifest.components
	if (components != null) {
		for (let i = 0; i < components.length; i++) {
			const c = components[i]
			const configJson = c.config != null ? JSON.stringify(c.config) : ''
			
			executeSQL(
				"INSERT OR REPLACE INTO meta_components (id, tab_id, type, title, config_json, sort_order) VALUES (?, ?, ?, ?, ?, ?)",
				[c.id, c.tab_id, c.type, c.title, configJson, c.sort_order]
			)
			count++
		}
	}
	
	// 导入数据记录
	const records = manifest.records
	if (records != null) {
		for (let i = 0; i < records.length; i++) {
			const r = records[i]
			const dataJson = r.data != null ? JSON.stringify(r.data) : ''
			
			executeSQL(
				"INSERT OR REPLACE INTO data_records (record_id, component_id, data_json, created_at) VALUES (?, ?, ?, ?)",
				[r.record_id, r.component_id, dataJson, Date.now()]
			)
			count++
		}
	}
	
	return count
}

/**
 * 保存工艺数据到数据库
 */
function saveProcessesToDatabase(processes: ProcessInfo[]): Promise<void> {
	return new Promise((resolve: () => void, reject: (reason: Error) => void) => {
		const savePromises: Promise<any>[] = []
		
		for (let i = 0; i < processes.length; i++) {
			const process = processes[i]
			
			// 插入工艺主表
			const insertProcessSQL = `
				INSERT OR REPLACE INTO t_process 
				(id, code, name, version, status, product_id, product_name, product_model, step_count, created_at, updated_at, data_json)
				VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
			`
			
			const processParams: any[] = [
				process.id,
				process.code,
				process.name,
				process.version,
				process.status,
				process.product.id,
				process.product.name,
				process.product.model,
				process.steps.length,
				process.createdAt,
				process.updatedAt,
				JSON.stringify(process)
			]
			
			savePromises.push(executeSQL(insertProcessSQL, processParams))
			
			// 插入工艺步骤
			for (let j = 0; j < process.steps.length; j++) {
				const step = process.steps[j]
				const insertStepSQL = `
					INSERT INTO t_process_step 
					(process_id, step_no, name, description, duration, tools_json, materials_json, images_json, videos_json)
					VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
				`
				
				const stepParams: any[] = [
					process.id,
					step.stepNo,
					step.name,
					step.description,
					step.duration,
					JSON.stringify(step.tools),
					JSON.stringify(step.materials),
					JSON.stringify(step.images),
					JSON.stringify(step.videos)
				]
				
				savePromises.push(executeSQL(insertStepSQL, stepParams))
			}
			
			// 插入附件
			for (let k = 0; k < process.attachments.length; k++) {
				const attachment = process.attachments[k]
				const insertAttachmentSQL = `
					INSERT INTO t_process_attachment 
					(process_id, type, name, path)
					VALUES (?, ?, ?, ?)
				`
				
				const attachmentParams: any[] = [
					process.id,
					attachment.type,
					attachment.name,
					attachment.path
				]
				
				savePromises.push(executeSQL(insertAttachmentSQL, attachmentParams))
			}
		}
		
		Promise.all(savePromises)
			.then(() => {
				resolve()
			})
			.catch((e: any) => {
				reject(new Error(e.toString()))
			})
	})
}

