/**
 * MPM 工艺预览系统 - 本地数据库服务
 * @description 封装 SQLite 数据库操作
 */

// #ifdef APP-ANDROID
import { UTSAndroid } from "dcloudio.uts.android";
import SQLiteDatabase from 'android.database.sqlite.SQLiteDatabase';
import Cursor from 'android.database.Cursor';
// #endif

/**
 * 数据库名称
 */
const DB_NAME: string = 'mpm_offline.db'

/**
 * 数据库版本
 */
const DB_VERSION: number = 1

/**
 * 数据库实例引用
 */
// #ifdef APP-ANDROID
let dbInstance: SQLiteDatabase | null = null
// #endif
// #ifdef WEB
let dbInstance: IDBDatabase | null = null
// #endif
// #ifdef APP-HARMONY
let dbInstance: any = null
// #endif


/**
 * 初始化数据库
 * @returns Promise<boolean> 初始化是否成功
 */
export function initDatabase(): Promise<boolean> {
	return new Promise((resolve: (value: boolean) => void, reject: (reason: Error) => void) => {
		// #ifdef APP-ANDROID
		initSQLiteDatabase()
			.then(() => {
				createTables()
					.then(() => {
						resolve(true)
					})
					.catch((e: any) => {
						reject(new Error(JSON.stringify(e)))
					})
			})
			.catch((e: any) => {
				reject(new Error(JSON.stringify(e)))
			})
		// #endif
		
		// #ifdef APP-HARMONY
		resolve(true)
		// #endif
		
		// #ifdef WEB
		initIndexedDB()
			.then(() => {
				resolve(true)
			})
			.catch((e: any) => {
				reject(new Error(JSON.stringify(e)))
			})
		// #endif
	})
}

/**
 * 初始化 SQLite 数据库（App端）
 */
function initSQLiteDatabase(): Promise<void> {
	return new Promise((resolve: () => void, reject: (reason: Error) => void) => {
		try {
			// #ifdef APP-ANDROID
			const context = UTSAndroid.getAppContext()
			if (context != null) {
				const dbPath = context.getDatabasePath(DB_NAME).getAbsolutePath()
				dbInstance = SQLiteDatabase.openOrCreateDatabase(dbPath, null)
				console.log('数据库打开成功')
				resolve()
			} else {
				reject(new Error('无法获取 Android Context'))
			}
			// #endif
			
			// #ifdef APP-HARMONY
			resolve()
			// #endif
		} catch (e: any) {
			reject(new Error(e.toString()))
		}
	})
}

/**
 * 创建数据表
 */
function createTables(): Promise<void> {
	return new Promise((resolve: () => void, reject: (reason: Error) => void) => {
		const createProcessTableSQL = `
			CREATE TABLE IF NOT EXISTS t_process (
				id TEXT PRIMARY KEY,
				code TEXT NOT NULL,
				name TEXT NOT NULL,
				version TEXT,
				status TEXT,
				product_id TEXT,
				product_name TEXT,
				product_model TEXT,
				step_count INTEGER DEFAULT 0,
				created_at TEXT,
				updated_at TEXT,
				data_json TEXT
			)
		`
		
		const createStepTableSQL = `
			CREATE TABLE IF NOT EXISTS t_process_step (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				process_id TEXT NOT NULL,
				step_no INTEGER NOT NULL,
				name TEXT NOT NULL,
				description TEXT,
				duration INTEGER DEFAULT 0,
				tools_json TEXT,
				materials_json TEXT,
				images_json TEXT,
				videos_json TEXT
			)
		`
		
		const createAttachmentTableSQL = `
			CREATE TABLE IF NOT EXISTS t_process_attachment (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				process_id TEXT NOT NULL,
				type TEXT,
				name TEXT,
				path TEXT
			)
		`
		
		const createTabGroupsTableSQL = `
			CREATE TABLE IF NOT EXISTS meta_tab_groups (
				id TEXT PRIMARY KEY,
				name TEXT,
				description TEXT,
				sort_order INTEGER
			)
		`
		
		const createTabsTableSQL = `
			CREATE TABLE IF NOT EXISTS meta_tabs (
				id TEXT PRIMARY KEY,
				group_id TEXT,
				title TEXT,
				app_id TEXT,
				sort_order INTEGER,
				visible_condition TEXT
			)
		`
		// Note: indices should be created separately or after table creation
		
		const createComponentsTableSQL = `
			CREATE TABLE IF NOT EXISTS meta_components (
				id TEXT PRIMARY KEY,
				tab_id TEXT,
				type TEXT,
				title TEXT,
				config_json TEXT,
				sort_order INTEGER
			)
		`
		
		const createDataRecordsTableSQL = `
			CREATE TABLE IF NOT EXISTS data_records (
				record_id TEXT PRIMARY KEY,
				component_id TEXT,
				data_json TEXT,
				created_at INTEGER
			)
		`
		
		const createPackageTableSQL = `
			CREATE TABLE IF NOT EXISTS t_import_package (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				file_name TEXT,
				version TEXT,
				source TEXT,
				process_count INTEGER,
				import_time TEXT,
				checksum TEXT
			)
		`
		
		// #ifdef APP-ANDROID
		if (dbInstance != null) {
			try {
				dbInstance!.execSQL(createProcessTableSQL)
				dbInstance!.execSQL(createStepTableSQL)
				dbInstance!.execSQL(createAttachmentTableSQL)
				dbInstance!.execSQL(createPackageTableSQL)
				
				// Dynamic Tab System Tables
				dbInstance!.execSQL(createTabGroupsTableSQL)
				dbInstance!.execSQL(createTabsTableSQL)
				dbInstance!.execSQL("CREATE INDEX IF NOT EXISTS idx_tab_group ON meta_tabs(group_id)")
				dbInstance!.execSQL(createComponentsTableSQL)
				dbInstance!.execSQL("CREATE INDEX IF NOT EXISTS idx_comp_tab ON meta_components(tab_id)")
				dbInstance!.execSQL(createDataRecordsTableSQL)
				dbInstance!.execSQL("CREATE INDEX IF NOT EXISTS idx_data_comp ON data_records(component_id)")

				console.log('数据表创建成功')
				resolve()
			} catch(e: any) {
				console.error('数据表创建失败：', e)
				reject(new Error(e.toString()))
			}
		} else {
			resolve()
		}
		// #endif
		
		// #ifdef APP-HARMONY
		resolve()
		// #endif
	})
}

/**
 * 执行 SQL 语句
 * @param sql - SQL 语句
 * @param params - 参数数组
 */
export function executeSQL(sql: string, params: any[] = []): Promise<any> {
	return new Promise((resolve: (value: any) => void, reject: (reason: Error) => void) => {
		// #ifdef APP-ANDROID
		if (dbInstance == null) {
			reject(new Error('数据库未初始化'))
			return
		}
		
		try {
			if (params.length > 0) {
				const args = params.map((p):any => p)
				dbInstance!.execSQL(sql, args.toTypedArray())
			} else {
				dbInstance!.execSQL(sql)
			}
			resolve(true)
		} catch (e: any) {
			console.error('SQL 执行失败：', sql, e)
			reject(new Error('SQL 执行失败: ' + e.toString()))
		}
		// #endif
		
		// #ifdef APP-HARMONY
		resolve(true)
		// #endif
		
		// #ifdef WEB
		console.warn('Web 端 IndexedDB 不支持直接 SQL 执行')
		resolve(null)
		// #endif
	})
}

/**
 * 查询数据
 * @param sql - 查询 SQL
 * @param params - 参数数组
 */
export function querySQL(sql: string, params: any[] = []): Promise<any[]> {
	return new Promise((resolve: (value: any[]) => void, reject: (reason: Error) => void) => {
		// #ifdef APP-ANDROID
		if (dbInstance == null) {
			reject(new Error('数据库未初始化'))
			return
		}
		
		try {
			let args: string[] | null = null
			if (params.length > 0) {
				args = params.map((p):string => {
					if (p == null) return ''
					return p.toString()
				})
			}
			
			const cursor = dbInstance!.rawQuery(sql, args != null ? args.toTypedArray() : null)
			const result: any[] = []
			
			if (cursor.moveToFirst()) {
				do {
					const row: any = {}
					const columnCount = cursor.getColumnCount()
					for (let i = 0; i < columnCount; i++) {
						const columnName = cursor.getColumnName(i)
						const type = cursor.getType(i)
						
						if (type == 3) { // STRING
							row[columnName] = cursor.getString(i)
						} else if (type == 1) { // INTEGER
							row[columnName] = cursor.getLong(i)
						} else if (type == 2) { // FLOAT
							row[columnName] = cursor.getDouble(i)
						} else if (type == 0) { // NULL
							row[columnName] = null
						} else if (type == 4) { // BLOB
							row[columnName] = null 
						}
					}
					result.push(row)
				} while (cursor.moveToNext())
			}
			cursor.close()
			resolve(result)
		} catch (e: any) {
			console.error('查询失败：', sql, e)
			reject(new Error('查询失败: ' + e.toString()))
		}
		// #endif
		
		// #ifdef APP-HARMONY
		resolve([] as any[])
		// #endif
		
		// #ifdef WEB
		resolve([] as any[])
		// #endif
	})
}

/**
 * 关闭数据库
 */
export function closeDatabase(): void {
	// #ifdef APP-ANDROID
	if (dbInstance != null) {
		try {
			dbInstance!.close()
			dbInstance = null
			console.log('数据库关闭成功')
		} catch (e: any) {
			console.error('数据库关闭失败：', e)
		}
	}
	// #endif
}

/**
 * 开启事务
 */
export function beginTransaction(): void {
	// #ifdef APP-ANDROID
	if (dbInstance != null) {
		dbInstance!.beginTransaction()
	}
	// #endif
}

/**
 * 标记事务成功
 */
export function setTransactionSuccessful(): void {
	// #ifdef APP-ANDROID
	if (dbInstance != null) {
		dbInstance!.setTransactionSuccessful()
	}
	// #endif
}

/**
 * 结束事务
 */
export function endTransaction(): void {
	// #ifdef APP-ANDROID
	if (dbInstance != null) {
		dbInstance!.endTransaction()
	}
	// #endif
}

// #ifdef WEB
// Web 端数据库版本，变更需增加版本号
const WEB_DB_VERSION: number = 2

/**
 * 初始化 IndexedDB（Web端）
 */
function initIndexedDB(): Promise<void> {
	return new Promise((resolve: () => void, reject: (reason: Error) => void) => {
		try {
			const request = indexedDB.open(DB_NAME, WEB_DB_VERSION)
			
			request.onerror = (_event: Event) => {
				reject(new Error('IndexedDB 打开失败'))
			}
			
			request.onsuccess = (_event: Event) => {
				dbInstance = request.result
				console.log('IndexedDB 打开成功')
				resolve()
			}
			
			request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
				const db = (event.target as IDBOpenDBRequest).result
				
				// 工艺数据表
				if (!db.objectStoreNames.contains('t_process')) {
					const processStore = db.createObjectStore('t_process', { keyPath: 'id' })
					processStore.createIndex('code', 'code', { unique: false })
					processStore.createIndex('name', 'name', { unique: false })
				}
				
				// 工艺步骤表
				if (!db.objectStoreNames.contains('t_process_step')) {
					const stepStore = db.createObjectStore('t_process_step', { keyPath: 'id', autoIncrement: true })
					stepStore.createIndex('process_id', 'process_id', { unique: false })
				}
				
				// 工艺附件表
				if (!db.objectStoreNames.contains('t_process_attachment')) {
					const attachStore = db.createObjectStore('t_process_attachment', { keyPath: 'id', autoIncrement: true })
					attachStore.createIndex('process_id', 'process_id', { unique: false })
				}
				
				// UI 分组表
				if (!db.objectStoreNames.contains('meta_tab_groups')) {
					db.createObjectStore('meta_tab_groups', { keyPath: 'id' })
				}
				
				// UI Tab表
				if (!db.objectStoreNames.contains('meta_tabs')) {
					const tabStore = db.createObjectStore('meta_tabs', { keyPath: 'id' })
					tabStore.createIndex('group_id', 'group_id', { unique: false })
				}
				
				// UI 组件表
				if (!db.objectStoreNames.contains('meta_components')) {
					const compStore = db.createObjectStore('meta_components', { keyPath: 'id' })
					compStore.createIndex('tab_id', 'tab_id', { unique: false })
				}
				
				// 数据记录表
				if (!db.objectStoreNames.contains('data_records')) {
					const recordStore = db.createObjectStore('data_records', { keyPath: 'record_id' })
					recordStore.createIndex('component_id', 'component_id', { unique: false })
				}
				
				// 导入记录表
				if (!db.objectStoreNames.contains('t_import_package')) {
					db.createObjectStore('t_import_package', { keyPath: 'id', autoIncrement: true })
				}
				
				console.log('IndexedDB Object Stores 创建/更新完成')
			}
		} catch (e: any) {
			reject(new Error(e.toString()))
		}
	})
}

/**
 * Web 端保存数据到 IndexedDB
 */
export function webPutData(storeName: string, data: any): Promise<void> {
	return new Promise((resolve: () => void, reject: (reason: Error) => void) => {
		if (dbInstance == null) {
			reject(new Error('IndexedDB 未初始化'))
			return
		}
		
		try {
			const transaction = dbInstance.transaction([storeName], 'readwrite')
			const store = transaction.objectStore(storeName)
			const request = store.put(data)
			
			request.onsuccess = () => {
				resolve()
			}
			request.onerror = () => {
				reject(new Error('IndexedDB put 失败: ' + storeName))
			}
		} catch (e: any) {
			reject(new Error(e.toString()))
		}
	})
}

/**
 * Web 端从 IndexedDB 查询所有数据
 */
export function webGetAll(storeName: string): Promise<any[]> {
	return new Promise((resolve: (value: any[]) => void, reject: (reason: Error) => void) => {
		if (dbInstance == null) {
			reject(new Error('IndexedDB 未初始化'))
			return
		}
		
		try {
			const transaction = dbInstance.transaction([storeName], 'readonly')
			const store = transaction.objectStore(storeName)
			const request = store.getAll()
			
			request.onsuccess = () => {
				resolve(request.result || [])
			}
			request.onerror = () => {
				reject(new Error('IndexedDB getAll 失败: ' + storeName))
			}
		} catch (e: any) {
			reject(new Error(e.toString()))
		}
	})
}

/**
 * Web 端按索引查询数据
 */
export function webGetByIndex(storeName: string, indexName: string, value: any): Promise<any[]> {
	return new Promise((resolve: (value: any[]) => void, reject: (reason: Error) => void) => {
		if (dbInstance == null) {
			reject(new Error('IndexedDB 未初始化'))
			return
		}
		
		try {
			const transaction = dbInstance.transaction([storeName], 'readonly')
			const store = transaction.objectStore(storeName)
			const index = store.index(indexName)
			const request = index.getAll(value)
			
			request.onsuccess = () => {
				resolve(request.result || [])
			}
			request.onerror = () => {
				reject(new Error('IndexedDB getByIndex 失败'))
			}
		} catch (e: any) {
			reject(new Error(e.toString()))
		}
	})
}

/**
 * Web 端清空 Store
 */
export function webClearStore(storeName: string): Promise<void> {
	return new Promise((resolve: () => void, reject: (reason: Error) => void) => {
		if (dbInstance == null) {
			reject(new Error('IndexedDB 未初始化'))
			return
		}
		
		try {
			const transaction = dbInstance.transaction([storeName], 'readwrite')
			const store = transaction.objectStore(storeName)
			const request = store.clear()
			
			request.onsuccess = () => {
				resolve()
			}
			request.onerror = () => {
				reject(new Error('IndexedDB clear 失败: ' + storeName))
			}
		} catch (e: any) {
			reject(new Error(e.toString()))
		}
	})
}

/**
 * Web 端获取记录数
 */
export function webGetCount(storeName: string): Promise<number> {
	return new Promise((resolve: (value: number) => void, reject: (reason: Error) => void) => {
		if (dbInstance == null) {
			reject(new Error('IndexedDB 未初始化'))
			return
		}
		
		try {
			const transaction = dbInstance.transaction([storeName], 'readonly')
			const store = transaction.objectStore(storeName)
			const request = store.count()
			
			request.onsuccess = () => {
				resolve(request.result)
			}
			request.onerror = () => {
				reject(new Error('IndexedDB count 失败: ' + storeName))
			}
		} catch (e: any) {
			reject(new Error(e.toString()))
		}
	})
}
// #endif

